(* ::Package:: *)

(* ::Title:: *)
(*QMRITools CardiacTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`CardiacTools`", {"Developer`"}];

$ContextPath=Union[$ContextPath,System`$QMRIToolsContextPaths];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


HelixAngleCalc::usage = 
"HelixAngleCalc[eigenvectors, mask, vox] calculates the helix angle matrix of cardiac data using only a left ventricle mask.
HelixAngleCalc[eigenvectors, mask, vox] calculates the helix angle matrix of cardiac data using only a left ventricle mask, and a maskp for visualization.
HelixAngleCalc[eigenvectors, mask, centerpoint, vec, inout, vox]  calculates the helix angle matrix of cardiac data using only a left ventricle mask.
HelixAngleCalc[eigenvectors, mask, maskp, centerpoint, vec, inout, vox] calculates the helix angle matrix of cardiac data using a left vantricle mask and a maskp for visualization.

eigenvectors are the tensor eigenvectors calculated with EigenvecCalc.
mask is a mask of the left ventricle.
maskp is a mask used for visualization.
vox is the voxels size, {slice, x, y}.

The folowing values are calculated automaticlay Using CentralAxes but can also be provided as an input.
centerpoint is the center of each slice calculated with CentralAxes.
inout is the inner and outer radius calcualted with CentralAxes.
vec is the vector describin the central axes of the heart, calculated with CentralAxes.

Output is het fiber angle matrix FAM = {9, slice, x, y} or {FAM, plot}.

DOI: 10.1186/1532-429X-17-S1-P15."


CalculateWallMap::usage = 
"CalculateWallMap[mask,vox] calculates the wall distance map and the wall derivative.

Output is {wallmap, wallDerivative}."

CentralAxes::usage = 
"CentralAxes[mask, vox] calculates the center of the lumen from a mask of the left ventricle. vox is the voxels size, {slice, x, y}.
CentralAxes[mask, maskp, vox] allows for fancy visualization of the other structures using maskp.

Output is {centerpoints, normalvecs, inout} or {centerpoints, normalvecs, inout, fit}."


CardiacSegment::usage = 
"CardiacSegment[data, mask, off] allows to segment the heart in 1, 4, 6 or AHA-17 segements for each slice 360 radial samples are generated.

data is a background image on which all overlays are projected. 
mask is the mask of the left ventricle (same as used for CentralAxes) and defines the area in which the data is sampled.
off is the centerpoints generated by CentralAxes.

Output is {segmask, segang, {points, slices}}."

PlotSegments::usage = 
"PlotSegments[mask, data, segang] shows how the heart wil be sampled by RadialSample. 

mask is a mask the left ventricle that was used in the CardiacSegment.
function and the segang is the output of the cardaic SegmentFunction.

Output is a plot window."

PlotSegmentMask::usage = 
"PlotSegmentMask[mask, segmask, vox] plots the mask segements created by CardiacSegment.

mask is a mask the left ventricle that was used in the CardiacSegment.
segmask is the output of CardiacSegemnt.
vox is the voxels size, {slice, x, y}.

Output is a plot window."


RadialSample::usage = 
"RadialSample[mask, data, segang] radialy samples the provided parametermap data. 

The mask should be a mask of the left ventricle that was used in the CardiacSegment.
segang is the output of the cardaic SegmentFunction.

Output is {points, vals} which are orderd as indicated by the user."

TransmuralPlot::usage = 
"TransmuralPlot[data] plots transmural profiles of the data which are created by RadialSample.

data can be a single profile or a list of profiles. In the second case the mean and standardeviations are plotted.

Output is a plot of the transmural profile."


MaskHelix::usage = 
"MaskHelix[helix, mask] masks helix angle data, sets the background to -100 and allows for Median filter of the helix mask.
helix can be a singel map or the FAM.

Output is the masked helix angle data."

BullseyePlot::usage = 
"BullseyePlot[data, segmask] generates a AHA-17 segement bullseye plot. 
BullseyePlot[list] generates a AHA-17 segement bullseye plot of the lists (which needs to have 17 values) provide.

data is a 3D volume used for the plot. 
segmask is the AHA-17 segmentation resulting form the CardiacSegment function when AHA17 is selected.

Output is a bullseye plot or a plotwindow, depending on the Method which can be \"Dynamic\" else it will be static.

DOI: 10.1161/hc0402.102975."

ExcludeSlices::usage = 
"ExcludeSlices[data] excludes slices that do not look like the others based on various distance measures.

Output is an array with 1 or 0 with the dimensiosn {slices, diff dirs}"


MakeECVBloodMask::usage = 
"MakeECVBloodMask[T1pre, T1post] makes a bloodpool mask based on the T1pre and T1post images. It assumes that the hart is cropped with the blood in the center."


ECVCalc::usage = 
"ECVCalc[T1pre, T1post, hema] calculates the ECVmap using MakeECVBloodMask.
ECVCalc[T1pre, T1post, bloodMask, hema] calculates the ECVmap using bloodMask."


CreateHeart::usage = 
"CreateHeart[] creates a simulated left ventricle shape.
CreateHeart[pars] creates a simulated left ventricle shape with predifined parameters pars.

Output is the heart shape, the voxel size and the parameters needed to generate the heart, {mask, vox, pars}.
"

CardiacCoordinateSystem::usage = 
"CardiacCoordinateSystem[mask, vox] creates the cardiac coordinate system within the mask. 
output is a set of vectors {radvecn, norvecc, cirvec}, being the radial, normal and circular axes of each voxel respectivley."


(* ::Subsection::Closed:: *)
(*Options*)


ShowHelixPlot::usage = 
"ShowHelixPlot is an option for HelixAngleCalc. If true the it also outputs a visulization of the local myocardial coordinate system."

HelixMethod::usage = 
"HelixMethod is an option for HelixAngleCalc. Can be \"Slow\" or \"Fast\". 
\"Slow\" uses wall distance interpolation and can take long for high res datasets.
\"Fast\" uses wall distance calculation using circular approximation of the ventricle."

AxesMethod::usage = 
"AxesMethod is an option for HelixAngleCalc and CentralAxes. Can be \"Linear\", \"Quadratic\", \"Cubic\"."

RowSize::usage =
"RowSize is an option for CentralAxes. defines the number or images per showing the segmentation.
Can be \"Automatic\" of an integer." 

ShowFit::usage = 
"ShowFit is an option for CentralAxes. True shows the fit of the central axes."

MaskWallMap::usage = 
"MaskWallMap is an option for CalculateWallMap. if True or False."


StartPoints::usage = 
"StartPoints is an option for CardiacSegment. Value is \"Default\" or the point list given by CardiacSegment."

StartSlices::usage = 
"StartSlices is an option for CardiacSegment. Value is \"Default\" or the list given by CardiacSegment."

LineThreshold::usage = 
"LineThreshold is an option for CardiacSegment. Can be number between 0 and 1. Increasing the value will decrease the amount of wall sampled."

LineStep::usage = 
"LineStep is an option for CardiacSegment."

RadialSamples::usage =
"RadialSamples is an option for RadialSample and PlotSegments. Defines how manny transmural samples are taken."

DropSamples::usage = 
"DropSamples is an option for RadialSample and PlotSegments. Defines how manny samples are droped form star and end. Can be an number or set (strat, end) of numbers."

GridLineSpacing::usage = 
"GridLineSpacing is an option of TransmuralPlot. It defines the spacing of the gridlines.";


SmoothHelix::usage = 
"SmoothHelix is an option for MaskHelix, sets the kernelsize for the MedianFilter." 

BackgroundValue::usage = 
"BackgroundValue is an option for MaskHelix. Sets the backgroud value (default is -100)."

TextOffset::usage = 
"TextOffset is an option for BullseyePlot. Determines where the text is placed, can be 0 to 1."

TextSize::usage = 
"TextSize is an option for BullseyePlot. Determines the text size."

BullPlotMethod::usage = 
"BullPlotMethod is an option for BullseyePlot. Can be \"Dynamic\" of \"Normal\". 
\"Dynamic\" allows to change plotting parameters in Manipulation window."

CutOffMethod::usage =
"CutOffMethod is an option for ExcludeSlices. Default value is \"Auto\" or it can be a fixed percentage (value between 0 and .5)"

DistanceMeasure::usage = 
"DistanceMeasure is an option for ExcludeSlices. Defaul value is 5. (1 ManhattanDistance, 2 SquaredEuclideanDistance, 3 EuclideanDistance, 4 Correlation, 5 SpearmanRho"


BloodMaskRange::usage = 
"BloodMaskRange is an option for MakeECVBloodMask." 

OutputCheckImage
"OutputCheckImage is an option for MakeECVBloodMask." 	


(* ::Subsection:: *)
(*Error Messages*)


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*HelixAngleCalc*)


(* ::Subsubsection::Closed:: *)
(*HelixAngleCalc*)


Options[HelixAngleCalc]={ShowHelixPlot->True, HelixMethod->"Slow", AxesMethod->"Quadratic"};

SyntaxInformation[HelixAngleCalc]={"ArgumentsPattern"->{_,_,_,_.,OptionsPattern[]}};

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:=HelixAngleCalc[data,mask,0,1,1,1,vox,opts]

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, maskp_?ArrayQ, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:=HelixAngleCalc[data,mask,maskp,1,1,1,vox,opts]

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, off_, vec_, inout_, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:=HelixAngleCalc[data,mask,0,off,vec,inout,vox,opts]

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, maskp_, offi_, veci_, inouti_, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, OptionsPattern[]]:=Module[
{norvec,radvec,radvecn,cirvec,projection,helix,sign,
evec,inp,dim,wallangmap,norvecc,mtot,func2,vec,off,inout,pl,
vectorField,vectorFieldE,n,coo,plot,out,voxl,offp,
rav,nov,rov,spz,spxy,sp,met,
seg,min,mout,intdata,func,wall,der,
maskCont,vec1,vec2,vec3},

dim=Dimensions[data][[1;;3]];
voxl=Reverse[vox];

met=OptionValue[HelixMethod];

If[offi===1&&veci===1&&inouti===1,
	If[OptionValue[ShowHelixPlot],
		{off, vec, inout, pl} = CentralAxes[mask, maskp, vox, RowSize -> Automatic, AxesMethod -> OptionValue[AxesMethod],ShowFit->OptionValue[ShowHelixPlot]];,
		{off, vec, inout} = CentralAxes[mask, maskp, vox, RowSize -> Automatic, AxesMethod -> OptionValue[AxesMethod],ShowFit->OptionValue[ShowHelixPlot]];
		];
	,
	vec=veci;off=offi;inout=inouti;
	];

Switch[met
	,"Fast",
	(*calculate the wall angle map*)
	wallangmap=N[WallAngleMap[mask,vox,inout]Degree];
	(*define te rad vector using center points*)
	radvec=RadVecC[dim,off];
	(*define norvecs using centerline vectors*)
	norvec=ConstantArray[vec[[#]],dim[[2;;]]]&/@Range[dim[[1]]];
	(*define rotation vectors perpendicualr to radvecn and norvec*)
	cirvec=NormalizeC[CrossC[radvec,norvec]];
	(*correct the norvec for the wall curvature by rotation around rotvec*)
	norvecc=NorVecR[wallangmap,cirvec,norvec];
	(*make radvec purpendicular to corrected norvec*)
	radvecn=MakePerpendicular[radvec,norvecc];
	
	,"Slow",
	
	seg = MorphologicalComponents[#] & /@ (1. - mask);
	min = Round@GaussianFilter[Unitize[Clip[seg, {1.5, 2}, {0, 0}]], 3];
	mout = Round@GaussianFilter[Unitize[1 - Clip[seg, {0, 1}, {0, 0}]], 3];
	mtot = (Dilation[mout, 1] + 1) - 2 min;
	
	intdata = N@Join[Append[vox #, 0.] & /@ Position[min, 1], Append[vox #, 1.] & /@ Position[1 - Dilation[mout, 1], 1]];
	func = Interpolation[intdata, InterpolationOrder -> 1];
	func2 = If[(mtot[[##]] & @@ #) != 2, (mtot[[##]] & @@ #), func @@ (vox #)] &;
	wall = Table[func2[{z, y, x}], {z, 1,dim[[1]]}, {y, 1, dim[[2]]}, {x, 1,dim[[3]]}];
	der = GaussianFilter[wall, {1.5 (1/vox)/(1/vox[[1]])}, #] & /@ (IdentityMatrix[3]);
	
	radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
	norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
	norvecc = MakePerpendicular[norvec, radvecn];
	cirvec = NormalizeC[CrossC[radvecn,norvecc]];
	
	,"Slow2",
	{wall,der}=CalculateWallMap[mask, vox, ShowFit->False, MaskWallMap->False];
	
	radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
	norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
	norvecc = MakePerpendicular[norvec, radvecn];
	cirvec = NormalizeC[CrossC[radvecn,norvecc]];
];
PrintTemporary["LMCS is done"];

(*create helix angle maps*)
out = Flatten[Table[
	evec=Map[Reverse,data[[All,All,All,i]],{3}];
	(*align vector with projection vector*)
	evec=Sign2[DotC[{norvecc,radvecn,cirvec}[[j]],evec]] evec;
	(*evec=Sign2[DotC[{norvecc,radvecn,rotvec}[[j]],evec]] evec;*)
	(*Helix,Transverse,Sheet}*)
	projection = MakePerpendicular[evec, {radvecn,cirvec,norvecc}[[j]]];
	(*projection = MakePerpendicular[evec, {rotvec,norvec,radvecn}[[j]]];*)
	inp = DotC[projection,{cirvec,norvecc,radvecn}[[j]]];
	helix=ArcCos[Abs[inp]]/Degree;
	
	sign=If[(j==1 && i==1),Sign2[inp],1];
	sign helix
	, {i, 3}, {j, 3}],1];
	
	sp = Ceiling[Dimensions[mask]/{12, 24, 24}];
	
	{spz,spxy} = {sp[[1]], Min[sp[[2 ;; 3]]]};

If[OptionValue[ShowHelixPlot],
		(*creat a plot showing the local axes system*)
	maskCont = PlotMaskVolume[mask + maskp, vox];
	n = (spz 0.6 vox[[1]]){1, -1, 1} /vox;
  	vectorField = Table[
  		If[mask[[z, y, x]] == 0,
  			{None, None, None},
  			coo = {x, -y + dim[[2]] + 1, z};
  			rav = Reverse[n radvecn[[z, y, x]]];
  			nov = Reverse[n norvecc[[z, y, x]]];
  			rov = Reverse[n cirvec[[z, y, x]]];
  			{
  				{Darker[Green], Thick, Line[{coo(* - rav*), coo + rav}]},
  				{Darker[Blue], Thick, Line[{coo(* - nov*), coo + nov}]},
  				{Darker[Red], Thick, Line[{coo(* - rov*), coo + rov}]}
     		}
     		], {z, 1, dim[[1]], spz}, {y, 1,dim[[2]], spxy}, {x, 1, dim[[3]], spxy}
     	];
	{vec1, vec2, vec3} = DeleteCases[Flatten[#, 2], None] & /@ Transpose[vectorField, {2, 3, 4, 1}];
	     
	vectorFieldE = DeleteCases[Flatten[Table[
    	If[mask [[z, y, x]] == 0,
       		None,
        	coo = ({x, -y + dim[[2]], z} + {.5, .5, 0});
        	rav = n data[[z,y,x,3]];
        	nov = n data[[z,y,x,1]];
        	rov = n data[[z,y,x,2]];
	        {
	         {Green, Thick, Line[{coo - rav, coo + rav}]}, 
	         {Blue, Thick, Line[{coo - nov, coo + nov}]},
	         {Red, Thick, Line[{coo - rov, coo + rov}]}
	         }
	         ]
	     , {z, 1, dim[[1]],1}, {y, 1, dim[[2]], 3}, {x, 1, dim[[3]], 2}],3], None];
	     
	offp = {.5, .5+dim[[2]], 0} + {1, -1, 1} Reverse[#] & /@ DeleteCases[off, {}];
	(*cent=Show[ListPointPlot3D[offp,PlotStyle -> Directive[{Thick, Black, PointSize[Large]}]],Graphics3D[{Thick, Black, Line[offp]}]];*)
  	plot = Show[maskCont, Graphics3D[vec1], Graphics3D[vec2], Graphics3D[vec3](*,Graphics3D[vectorFieldE]*)];
   	Print[plot];
  	
  	{Re@out,{plot,pl}(*,{radvec,norvec,radvecn,rotvec,norvecc}*)}
	,
  	Re@out
  	]
]


(* ::Subsubsection::Closed:: *)
(*Sign2*)


Sign2[dat_]:=Sign[Sign[dat] + 0.0001];


(* ::Subsubsection::Closed:: *)
(*MakePerpendicular*)


MakePerpendicular[vec1_, vec2_] := NormalizeC[MakePerpendiculari[vec1, vec2]]


MakePerpendiculari = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
   vec1 - (vec1.vec2) vec2, RuntimeAttributes -> {Listable}, 
   Parallelization -> True, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NormalizeC*)


NormalizeC = Compile[{{vec, _Real, 1}}, Normalize[vec], RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*RadVecC*)


RadVecC = Compile[{{dim, _Real, 1}, {off, _Real, 2}}, 
   Table[Normalize[{i, j, k}-off[[i]]], {i, dim[[1]]}, {j, 
     dim[[2]]}, {k, dim[[3]]}], RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecC*)


NorVecC = Compile[{{off, _Real, 2}, {vec, _Real, 2}, {dim, _Real, 1}, {vox, _Real, 1}},
   Block[{offv = vox # & /@ off},
    Table[
     vec[[First@
        First@Position[offv, First@Nearest[offv, vox {i, j, k}, 1]]]],
     {i, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}]
    ], Parallelization -> True, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecR*)


NorVecR = Compile[{{angmap, _Real, 0}, {rotvec, _Real, 1}, {norvec, _Real, 1}},
   Block[{
     v1 = rotvec[[1]], v2 = rotvec[[2]], v3 = rotvec[[3]],
     W, iden = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}},
    W = -{{0, -v3, v2}, {v3, 0, -v1}, {-v2, v1, 0}};
    (iden + 
       Sin[angmap] W + (2 Sin[angmap/2]^2 MatrixPower[W, 2])).norvec
    ]
   , RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];



(* ::Subsubsection::Closed:: *)
(*CrossC*)


CrossC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
   Cross[vec1, vec2], RuntimeAttributes -> {Listable}, 
   Parallelization -> True];


(* ::Subsubsection::Closed:: *)
(*DotC*)


DotC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, vec1.vec2, 
   RuntimeAttributes -> {Listable}, Parallelization -> True];


(* ::Subsubsection::Closed:: *)
(*WallAngleMap*)


WallAngleMap[mask_, vox_, inout_] := 
 Module[{dim,cent,len,edge1,edge2,fout,fin,
   walldir,wallang,wallvec,sign,
   wallangfunc,dist,in,out},
  
  dim = Dimensions[mask];
  len = dim[[1]];
    
  (*fit the wall profile with Quadratic function*)
  {in, out} = (FitWall[#, "Quartic"]) & /@ {inout[[1, 2]], inout[[2, 2]]};
  fout = First@First@Position[out[[1]], _Real?(# != 0. &)];
  fin = First@First@Position[in[[1]], _Real?(# != 0. &)];
  
  walldir = {in, out};
wallang = Transpose[Map[(
      wallvec = Normalize[vox {1, #[[2]], 0}];
      sign = Sign2[#[[2]]];
      {#[[1]], sign VectorAngle[{1, 0, 0}, wallvec]/Degree}
      ) &, Transpose[walldir, {2, 3, 1}], {2}], {3, 1, 2}];
cent = {ConstantArray[0, len], wallang[[1, 2]]};
If[fout > 1, wallang[[2, 2, Range[fout - 1]]] = 90];
If[fin > 1, wallang[[1, 2, Range[fin - 1]]] = 90];
cent = {ConstantArray[0, len], wallang[[1, 2]]};
edge1 = {ConstantArray[ Max[walldir[[All, 1]]], len], wallang[[2, 2]]};
edge2 = {ConstantArray[ Max[vox dim], len], wallang[[2, 2]]};
wallang = 
  Transpose[{Transpose[
       vox[[1 ;; 2]] {Range[len], #[[1]]}], #[[2]]}] & /@ 
   Join[{cent}, wallang, {edge1, edge2}];

wallang = Sort[DeleteDuplicates[Flatten[wallang, 1]]];
wallangfunc = Interpolation[wallang, InterpolationOrder -> 1];
Table[
   dist = EuclideanDistance[{j, k}, inout[[1, 1, z, 2 ;;]]];
   wallangfunc[vox[[1]] z, vox[[2]] dist]
   , {z, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}
   ]
]


(* ::Subsubsection::Closed:: *)
(*FitWall*)


(*fit the waal profile for the normalized central axes*)
FitWall[data_, met_] := 
 Module[{fun, pf, fdata, xdat, points, pos},
  (*define function and data*)
  fun = Switch[met,
   "Quadratic", {1, t, t^2},
   "Cubic", {1, t, t^2, t^3},
   "Quartic", {1, t, t^2, t^3, t^4},
   _, {1, t}];
  xdat = Range[Length[data]];
  fdata = DeleteCases[Transpose[{xdat, data}], {_, {}}];
  
  (*perform the fit and gererate the fitted poins *)
  pf = Simplify@Chop@Fit[fdata, fun, t];
  points = Chop[pf /. t -> # & /@ xdat];
  
  (*set the radius to zero for slices without a mask*)
  pos = Flatten[Position[data, {}]];
  If[! (pos === {}), points[[pos]] = 0];
  {points, (Unitize[points[[#]]] (D[pf, t] /. t -> #) /. 
       0. -> 10) & /@ xdat}
  ]


(* ::Subsection::Closed:: *)
(*CalculateWallMap*)


Options[CalculateWallMap] = {ShowFit -> True, MaskWallMap->True};

SyntaxInformation[CalculateWallMap] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

CalculateWallMap[maski_, vox_, OptionsPattern[]] := Module[{
   seg, min, mout, mtot, pts, ptsi, pos, ptso, x, y, z, plane, maxd, 
   dis,mask,
   surfpl, pointspl, planepl, planefit, i, fit,
   planem, d1, d2, d3, zc, mask2, in, out, min2, mout2, clip,
   surfin, surfout, ptsin, ptsout, ptspl,
   inpnt, outpnt, wall, pt, pt1, pt2, dist1, dist12, dist22, dist2,
   ptsm, dist, der
   },
  
  mask=Round[ImageData[SelectComponents[Image[#], "Count", -1]] & /@ maski];
  (*create the inner and outer volume*)
  seg = MorphologicalComponents[#] & /@ (1. - mask);
  seg = If[#[[1, 1]] == 2, # /. {2 -> 1, 1 -> 2}, #] & /@ seg;
  min = Unitize[Clip[seg, {1.5, 2}, {0, 0}]];
  mout = Unitize[1 - Clip[seg, {0, 1}, {0, 0}]];
  mtot = (mout + 1) - 2 min;
  
  (*get the top points to fit top plane*)
  pts = ptsi = Flatten[MapIndexed[(
        pos = Position[#1, 1.] - 1;
        If[pos != {}, Join[Last[pos], #2], Nothing]
        ) &, N@TransData[mask, "l"], {2}], 1];
  ptso = {{0, 0, 0}};
  
  (*fit the top plane*)
  Clear[x, y, z];
  plane = Fit[Reverse /@ pts, {1, x, y}, {x, y}];
  maxd = Max[{(1./(0.5 Norm[vox])), 0.25}];
  While[ptsi != ptso,
   ptsi = ptso;
   ptso = Select[pts, (
       dis = (((plane - z) /. Thread[{x, y, z} -> Reverse[#]]));
       dis < 1.5 maxd || Abs[dis] < maxd
       ) &];
   plane = Fit[Reverse /@ ptso, {1, x, y}, {x, y}];
   ];
  
  (*plane fit visualisation*)
  surfpl = 
   ListContourPlot3D[GaussianFilter[mask, 1], Contours -> {0.6}, 
    Mesh -> False, 
    PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}], 
    BoxRatios -> Reverse@(vox Dimensions[mask]), 
    ContourStyle -> Directive[Gray, Opacity[0.5]], 
    Lighting -> "Neutral", Axes -> False];
  pointspl = 
   ListPointPlot3D[Reverse[# - {0, 1, 1}] & /@ ptsi, 
    PlotRange -> Transpose[{{0, 0, 0}, Reverse@Dimensions[mask]}], 
    BoxRatios -> 1, PlotStyle -> Red];
  planepl = 
   Plot3D[plane,  {x, 0, Dimensions[mask][[3]]}, {y, 0, 
     Dimensions[mask][[2]]}, Mesh -> False, 
    PlotStyle -> Directive[Red, Opacity[.2]], 
    BoundaryStyle -> Darker[Red]];
  planefit = 
   Show[surfpl, planepl, pointspl, PerformanceGoal -> "Speed"];

  (*make mask from plan*)
  planem = 0 mout;
  {d1, d2, d3} = Dimensions[planem];
  Table[
   zc = (Round[plane] + o) /. {x -> xc, y -> yc};
   If[zc <= d1 && mout[[zc, yc, xc]] != 1, 
    planem[[zc, yc, xc]] = 1], {xc, 1, d3}, {yc, 1, d2}, {o, 2, 5}];
  
  (*close gap between mask and top plane*)
  mask2 = mask;
  in = mask2; out = 0 mask2;
  i = 0;
  While[in != out && i < 50,
   i++;
   in = mask2;
   out = (1 - 
       min) (ArrayPad[
        Closing[ArrayPad[mask2 + planem, 20], 0.1], -20] - planem);
   mask2 = out;
   ];
  
  (*fill inner mask up to plane*)
  min2 = min;
  in = min2; out = 0 min2;
  clip = Clip[(1 - mask2 - planem), {0, 1}];
  i = 0;
  While[in != out && i < 50,
   i++;
   in = min2;
   out = clip ArrayPad[Dilation[ArrayPad[min2, 20], 0.1], -20];
   min2 = out;
   ];
  mout2 = ArrayPad[Closing[ArrayPad[mask + min2, 5], 1], -5];
  {min2, mout2};
  
  (*Create Inner and outer surfaces*)
  {surfout, surfin} = 
   ListContourPlot3D[GaussianFilter[min2 + mout2, 1], 
      Contours -> {0.3, 1.5}[[#]], 
      Mesh -> False,
      PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}],
      Lighting -> "Neutral", 
      BoxRatios -> Reverse@(vox Dimensions[mask]),
      ContourStyle -> Directive[{Red, Blue}[[#]], Opacity[0.4]], 
      MaxPlotPoints -> {50, 100}] & /@ {1, 2};
  
  (*get the coordinates from the inner and outer surface*)
  ptsin = Reverse /@ Cases[surfin, GraphicsComplex[x_, ___] :> x][[1]] + 1;
  ptsout = Reverse /@ Cases[surfout, GraphicsComplex[x_, ___] :> x][[1]] + 1;
  
  ptspl = Show[surfin, surfout, ListPointPlot3D[{Reverse /@ ptsin - 1, Reverse /@ ptsout - 1}, PlotStyle -> {Blue, Red}], PerformanceGoal -> "Speed",ImageSize->250];
  
  inpnt = N[vox # & /@ ptsin]; 
  outpnt = N[vox # & /@ ptsout];
  (*generate the wall distance function*)
  wall = 0 mask + 1;
  ptsm = N@Position[mask, 1];
  DistributeDefinitions[inpnt,outpnt];
  dist = Map[(
      pt = vox #;
      pt1 = Mean[Nearest[inpnt, pt, 3]];
      pt2 = Mean[Nearest[outpnt, pt, 3]];
      dist1 = Chop[Norm[pt1 - pt2]];
      dist12 = Chop[Norm[pt1 - pt]];
      dist22 = Chop[Norm[pt2 - pt]];
      dist2 = If[dist1 == 0., 0., Mean[{dist12/dist1, 1 - (dist22/dist1)}]];
      (*{pt1,pt,pt2,dist1,*)
      dist2
      ) &, ptsm];
      
  (*create the wall distance map*)
  MapThread[(wall[[#1[[1]], #1[[2]], #1[[3]]]] = #2) &, {ptsm, dist}];
  (*wall = MedianFilter[wall*(1 - min2), 2];*)
  wall = GaussianFilter[wall*(1 - min2), 2];  
  der = GaussianFilter[wall, {2 (1/vox)/(1/vox[[2]])}, #] & /@ (IdentityMatrix[3]); 
  
  
  
  If[OptionValue[MaskWallMap], 
  wall = mask wall;
  der = mask # & /@ der;
  {mn, mx}=Quantile[Flatten[GetMaskData[wall, mask]],{0.05,0.95}];
  wall = Clip[mask ((wall - mn)/(mx-mn)),{0,1}];
  ];
  
  If[OptionValue[ShowFit], fit = Print[GraphicsRow[{planefit, ptspl}, ImageSize -> 800]]];
  If[OptionValue[ShowFit], {wall, der, fit}, {wall, der}]
  ]


(* ::Subsection:: *)
(*CentralAxes*)


(* ::Subsubsection::Closed:: *)
(*CentralAxes*)


Options[CentralAxes]={ShowFit->True,RowSize->"Automatic",AxesMethod->"Cubic"(*,Output->True*)};

SyntaxInformation[CentralAxes]={"ArgumentsPattern"->{_,_,_.,OptionsPattern[]}};

CentralAxes[mask_,vox_,opts:OptionsPattern[]]:=CentralAxes[mask,0,vox,opts]

CentralAxes[mask_,maskp_,vox_,OptionsPattern[]]:=Module[{
rad,met,row,dim,half,minmaxr,inner,outer,inout,offi,offo,vecsi,vecso,
offouti,offouto,pl1,off,vecs,pl2,offout,vecsout,fit},

(*get option values*)
rad={0,1};
met=OptionValue[AxesMethod];
row=If[OptionValue[RowSize]==="Automatic"||!IntegerQ[OptionValue[RowSize]],
Round[Sqrt[Length[mask]]],
OptionValue[RowSize]
];

(*get data dimensions*)
dim=Dimensions[mask];
(*half=CenterPoint[mask];*)
half=Drop[dim,1]/2.;
minmaxr= rad Max[(Drop[dim,1]/1)];

(*get inner and outer radius*)
{inner,outer}=GetRadius[mask,minmaxr,half];
(*fit off centers*)
{off, vecs} = FitCenterLine[inner[[1]], outer[[1]], vox, met];
{offi, vecsi} = FitCenterLine[inner[[1]], vox, met];
{offo, vecso} = FitCenterLine[outer[[1]], vox, met];

{off, vecs} = BoundCorrect[Min /@ Transpose[{inner[[2]], outer[[2]]} /. {{} -> 0}], off, vecs];
{offi, vecsi} = BoundCorrect[inner[[2]]/. {{} -> 0}, offi, vecsi];
{offo, vecso} = BoundCorrect[outer[[2]]/. {{} -> 0}, offo, vecso];
  
(*generate plots*)
pl1 = PlotRadius[Clip[2mask + maskp,{0,2}], inner, outer];
pl2 = PlotSegmentation[mask + maskp, inner, outer, {off, offi, offo}, vox];
fit = Row[{GraphicsGrid[Partition[pl1, row, row, 1, {}], ImageSize -> row*100], pl2}];

(*create output*)
offout = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ off;
offouti = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offi;
offouto = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offo;
vecsout=Reverse[{1,-1,1} #]&/@vecs;
inout = {{offouti, inner[[2]]}, {offouto, outer[[2]]}};

If[OptionValue[ShowFit]==True,Print[fit]];
If[OptionValue[ShowFit],{offout,vecsout,inout,fit},{offout,vecsout,inout}]
]


(* ::Subsubsection::Closed:: *)
(*BoundCorrect*)


BoundCorrect[points_,off_,vec_]:=Block[{vv,first,last,offo,veco},
vv = Unitize[points];
	
first = (First@Position[vv, 1])[[1]];
last = (Last@Position[vv, 1])[[1]];
offo = Join[
	{off[[first, 1]] + (first - #) (off[[first, 1]] - off[[first + 1, 1]]), off[[first, 2]] + (first - #) (off[[first, 2]] - off[[first + 1, 2]]), #} & /@ Range[1, first - 1],
	off[[Range[first, last]]],
  	{off[[last, 1]] + (# - last) (off[[last, 1]] - off[[last - 1, 1]]), off[[last, 2]] + (# - last) (off[[last, 2]] - off[[last - 1, 2]]), #} & /@ Range[last + 1, Length[vv]]
  ];
veco=Join[ConstantArray[vec[[first]],first-1],vec[[first;;last]],ConstantArray[vec[[last]],Length[vv]-last]];
{offo,veco}
]


(* ::Subsubsection::Closed:: *)
(*CenterPoint*)


CenterPoint[mask_]:=Module[{half},
DynamicModule[{halfi},
halfi=Dimensions[mask[[1]]]/2;
DialogInput[{
LocatorPane[Dynamic[halfi],Image[Mean[mask],ImageSize->400],Appearance->Graphics[{Red,Disk[]},ImageSize->30]],
DefaultButton["Done",DialogReturn[half=halfi]]
},WindowTitle->"Select Center",WindowFloating->True,Modal->True]
];
half
]


(* ::Subsubsection::Closed:: *)
(*GetRadius*)


(*function to get inner and outer radius of the segmentation*)
GetRadius[mask_, {minr_, maxr_}, half_] := 
 Module[{msin, tmp, comps, seg, min, mout, inner, outer,seli,selo,spos}, 
   (*create the inner and outer volume*)
  seg = MorphologicalComponents[#] & /@ (1. - mask);
  seg = If[#[[1, 1]] == 2, # /. {2 -> 1, 1 -> 2}, #] & /@ seg;
  min = Unitize[Clip[seg, {1.5, 2}, {0, 0}]];
  mout = Unitize[1 - Clip[seg, {0, 1}, {0, 0}]];
  
  (*get the inner radius*)inner =
   Transpose@MapIndexed[(msin = Image[#1];
       tmp = DeleteCases[(ComponentMeasurements[msin, {"BoundingDiskCenter", "BoundingDiskRadius","Circularity"}])[[All,2]], _?((#1[[2]] > maxr) || (#1[[2]] < minr) &)];
       comps = 
        If[tmp != {}, 
         Nearest[(#[[1]] -> #) & /@ tmp, half, 1][[1]], {}];
       If[
        comps != {}, {Join[comps[[1]], (#2)], 
         comps[[2]]}, {{}, {}}]) &, min];
  (*get the outer radius*)
  outer = Transpose@MapIndexed[(msin = Image[#1];
       tmp = DeleteCases[(ComponentMeasurements[msin, {"BoundingDiskCenter", "BoundingDiskRadius"}])[[All, 2]], _?((#1[[2]] > maxr) || (#1[[2]] < minr) &)];
       comps = 
        If[tmp != {}, 
         Nearest[(#[[1]] -> #) & /@ tmp, half, 1][[1]], {}];
       If[
        comps != {}, {Join[comps[[1]], (#2)], 
         comps[[2]]}, {{}, {}}]) &, mout];
    (*only define outer if inner is known*)
    seli = Unitize[inner[[2]]] /. {} -> 0;
    selo = Unitize[outer[[2]]] /. {} -> 0;
    spos = Flatten@SequencePosition[seli + selo, {2, 1}];
    If[spos =!= {},spos = spos[[2]];outer[[All, spos ;;]] = outer[[All, spos ;;]] /. {{_, _, _} -> {}, _Real -> {}}];
  (*give inner and outer radius (centerpoint,radius)*)
  {inner, outer}
  ]


(* ::Subsubsection::Closed:: *)
(*FitCenterLine*)


(*fit the center line for the average inner and outer center points*)
FitCenterLine[inner_, outer_, vox_, met_] := 
 Module[{data},
  data = Mean[DeleteCases[#, {}]] & /@ Transpose[{inner, outer}];
  FitCenterLine[data, vox, met]
  ]

FitCenterLine[datai_, vox_, met_] := 
 Module[{fun, pf, xdat, data, fdata},
  data = datai /. {Mean[{}] -> {{}, {}, {}}, {} -> {{}, {}, {}}};
  
  fun = Switch[met, 
  	"Quadratic", {1, t, t^2}, 
    "Cubic", {1, t, t^2, t^3}, 
    "Quartic", {1, t, t^2, t^3, t^4},
    _, {1, t}];
  
  xdat = Range[Length[data]];
  fdata = DeleteCases[Transpose[{Range[Length[#]], #}], {_, {}}] & /@ Transpose[data];
  
  pf = Simplify@Chop@Fit[#1, fun, t] & /@ fdata;
  
  {
  	Transpose[If[NumberQ[#], ConstantArray[#, Length[xdat]], # /. t -> xdat] & /@ pf]
  , (Normalize[D[Reverse[vox] pf, t] /. t -> #] & /@ xdat)}
  ]


(* ::Subsubsection::Closed:: *)
(*PlotRadius*)


(*Plot the radus and center points on the mask*)
PlotRadius[mask_,inner_,outer_]:=MapThread[(
Show[
Image[#1/Max[mask],ImageSize->100],
If[#2[[1]]!={},Graphics[{Red,Thick,Circle[#2[[1,1;;2]]+{-0.25,0.25},#2[[2]]]}],Graphics[]],
If[#2[[1]]!={},Graphics[{Red,PointSize[Medium],Point[#2[[1,1;;2]]]}],Graphics[]],
If[#3[[1]]!={},Graphics[{Blue,Thick,Circle[#3[[1,1;;2]]+{-0.25,0.25},#3[[2]]]}],Graphics[]],
If[#3[[1]]!={},Graphics[{Blue,PointSize[Medium],Point[#3[[1,1;;2]]]}],Graphics[]]
]
)&,{mask,Transpose@inner,Transpose@outer}]


(* ::Subsubsection::Closed:: *)
(*PlotSegmentation*)


PlotSegmentation[mask_, inner_, outer_, {off_, offi_, offo_}, vox_] :=
  Module[{voxl, offp, offip, offop},
  voxl = Reverse[vox];
  
  offp = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[off, {}];
  offip = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offi, {}];
  offop = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offo, {}];
  
  Show[
   PlotMaskVolume[mask, vox],
   (*center points*)
   ListPointPlot3D[offp, PlotStyle -> Directive[{Thick, Black, PointSize[Large]}]],
   Graphics3D[{Thick, Black, Line[offp]}],
   
   ListPointPlot3D[Delete[outer[[1]], Position[outer[[2]], {}]], PlotStyle -> Directive[{Thick, Blue, PointSize[Large]}]],
   Graphics3D[{Thick, Blue, Line[Delete[offop, Position[outer[[2]], {}]]]}],
   
   ListPointPlot3D[Delete[offip, Position[inner[[2]], {}]], PlotStyle -> Directive[{Thick, Red, PointSize[Large]}]],
   Graphics3D[{Thick, Red, Line[Delete[offip, Position[inner[[2]], {}]]]}],
   
   (*Plot the segmented outlines*)
   If[outer[[2, #]] === {}, Graphics3D[], ParametricPlot3D[{outer[[2, #]] Sin[u], outer[[2, #]] voxl[[1]]/voxl[[2]] Cos[u],0} + offop[[#]], {u, 0, 2 Pi}, 
       PlotStyle -> Directive[{Thick, Blue, Opacity[.5]}]]] & /@ Range[Length[mask]], 
   If[inner[[2, #]] === {}, Graphics3D[], ParametricPlot3D[{inner[[2, #]] Sin[u], inner[[2, #]] voxl[[1]]/voxl[[2]] Cos[u], 0} + offip[[#]], {u, 0, 2 Pi}, 
       PlotStyle -> Directive[{Thick, Red, Opacity[.5]}]]] & /@ Range[Length[mask]],ImageSize->400
       
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotMaskVolume*)


Options[PlotMaskVolume] = {Filter->True}

PlotMaskVolume[mask_,vox_,color_:Darker[Gray],OptionsPattern[]] := Module[{pmask,dim},
	pmask = ArrayPad[Map[Reverse, 
		If[OptionValue[Filter],
		GaussianFilter[Clip[mask], 1],
		Clip[mask]
		], {1}], 1];
	dim=Dimensions[pmask];
	ListContourPlot3D[pmask, Contours -> {.4}, ContourStyle -> {color, Opacity[.5]}, Mesh -> False, 
    Lighting -> "Neutral", BoundaryStyle -> None, PlotRange -> (Thread[{{0, 0, 0}, Reverse@dim - 1}]), 
    BoxRatios -> Reverse[(vox (dim + 2))], Axes -> True, ImageSize -> 400, SphericalRegion -> True]
  ]


(* ::Subsection:: *)
(*CardiacSegment*)


(* ::Subsubsection::Closed:: *)
(*CardiacSegment*)


Options[CardiacSegment]={StartPoints->"Default",StartSlices->"Default",LineThreshold->.25,LineStep->.5(*,SegmentAngle->2*)};

SyntaxInformation[CardiacSegment] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

CardiacSegment[data_,maski_,off_,OptionsPattern[]]:=DialogInput[{
DynamicModule[{
mask,radiusStart,centers,pointsIn,coordinates,angles,segmask, segang,startPoint, revi, 
lines,centerpl,slices,api,midi,basi,sti,endi,carPl,colsOver,car,lm,pos,st,en,app,seg,allpli},

mask=Round[maski];
radiusStart=ConstantArray[Max[Dimensions[mask]]/8,Length[mask]];
centers=Reverse/@off[[All,2;;3]];

startPoint=OptionValue[StartPoints];
If[startPoint==="Default",
	revi=1;
	pointsIn=Transpose[{
		centers-Transpose@{radiusStart,radiusStart},
		centers-Transpose@{radiusStart,-radiusStart}
		},{2,1,3}];
	,
	If[NumberQ[startPoint[[2]]],
		revi=startPoint[[2]];
		pointsIn=Reverse@startPoint[[1]];
		,
		revi=1;
		pointsIn=Reverse@startPoint;
		]
	];

coordinates=(Reverse/@Position[#,1])&/@mask;
angles=Table[i,{i,0,359,1}]Degree;
PrintTemporary["Calculating sample lines"];
lines=LinePoints[mask, off,LineThreshold->OptionValue[LineThreshold],LineStep->OptionValue[LineStep]];

(*static plots*)
centerpl=Graphics[{Red ,Disk[#,1]}]&/@centers;

slices=Length[mask];

{sti,api,midi,basi,endi}=
If[OptionValue[StartSlices]==="Default"||OptionValue[StartSlices]==={},
	pos = Position[Max[#] & /@ mask, 1];
	st = First@First[pos-1];
	en = First@Last[pos];
	app=Round[(en-st)/7];
	seg=Ceiling@Range[st + app, en - (en - (app + st))/3, (en - (app + st))/3];
	Flatten[{st,seg,en}]
	,
	OptionValue[StartSlices]
];

carPl = ArrayPlot[car = Reverse@Total[Transpose[mask]], ColorFunction -> "GrayTones", Frame -> False,ImageSize -> {200, 200}, AspectRatio -> 1];
colsOver = 0 car;lm = Dimensions[car];
allpli=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lm[[2]], #1}}]} &, {{sti,api,midi,basi,endi}, {Gray, Orange, Blue, Red, Purple}}]];

PrintTemporary["Initializing manipulte window"];
Manipulate[
(*slice sements*)
end=Clip[end,{bas,slices}];
bas=Clip[bas,{mid,end}];
ap=Clip[ap,{start,mid}];
mid=Clip[mid,{ap,bas}];
start=Clip[start,{0,ap}];
(*app=Clip[app,{0,mid}];*)
n=Clip[n,{1,slices}];
allpl=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lmm, #1}}]} &, {{start,ap,mid,bas,end}, {Gray, Orange, Blue, Red, Purple}}]];

(*segment ranges*)
apex=Range[start+1,ap];
apical=Range[ap+1,mid];
midcavity=Range[mid+1,bas];
basal=Range[bas+1,end];
none=Complement[Range[1,slices],Flatten[{apex,apical,midcavity,basal}]];

(*Colors*)
backcols=Flatten[Thread/@Thread[{apex,apical,midcavity,basal,none}->{Orange,Blue,Red,Purple,Gray}]];
colls=backcols[[All,2]];
backcol=n/.backcols;

(*segments*)
segments=If[!NumberQ[segmi],
Thread[{apex,apical,midcavity,basal,none}->{1,4,6,6,1}][[1;;4]],
If[slcgrp,
DeleteCases[Thread[{apex,apical,midcavity,basal}->{segmi,segmi,segmi,segmi}],{}->_],
{Range[slices]->segmi}
]
];

segm=n/.Flatten[Thread/@segments];

(*get correct center, calcualte angles and rad*)
cent=centers[[n]];
rad=Clip[RadCalcC[points[[n]],cent],{5,Min[Dimensions[mask[[1]]]/2]}];
angs= VecAngleC[points[[n]],cent,segm,rev];

(*plots*)
anatomypl=ArrayPlot[data[[n]],ColorFunction->"GrayTones",FrameTicks->Automatic,DataReversed->True,ImageSize->400,Mesh->mesh,
LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],FrameTicksStyle->Directive[{Black,Thick}],FrameStyle->Directive[{Thick,backcol}]];
maskpl=If[masktype,
ArrayPlot[(1-Ceiling[GaussianFilter[mask[[n]],2]-linetr]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True],
ArrayPlot[(1-mask[[n]]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True]
];

(*circle and arrows*)
circplot=If[MemberQ[display,1],
	If[segm==1,
		Graphics[{backcol,Thick,Circle[cent,rad]}]
		,
		segpt=RotateRadC[rad,cent,#]&/@angs; 
		Graphics[{{Thick,backcol,Arrow[{cent,#}]&/@segpt},{backcol,Thick,Circle[cent,rad]}}]],
	Graphics[]];
(*lines1 - full lines*)
lineplot=If[MemberQ[display,2], 
	segpts=Map[RotateRadC[rad,cent,#]&,angsp,{2}];
	Graphics[Table[{ColFun[i,segm],Line[{cent,#}]&/@segpts[[i]]},{i,1,segm}]],
	Graphics[]];
(*points*)
pointplot=If[MemberQ[display,3],
	pts=RegionPoins[cent,angs,coordinates[[n]]];
	Graphics[Table[{ColFun[i,segm],PointSize[Large],Point[#-{.5,.5}&/@pts[[i]]]},{i,1,segm}]],
	Graphics[]];
(*disks*)
polplot=If[MemberQ[display,4],
	dsks=RegionDisk[cent,angs,rad,rev]; 
	Graphics[Table[{Opacity[0.5],ColFun[i,segm,backcol],dsks[[i]]},{i,1,segm}]],
	Graphics[]];
(*lines2 - mask lines*)
lineplot2=If[MemberQ[display,5],
	Graphics[Table[{ColFun[i,segm],Line[lines[[n,(#/Degree+1)]]]&/@angsp[[i]]},{i,1,segm}]],
	Graphics[]];
(*lines*)
If[MemberQ[display,2]||MemberQ[display,5],
	angsp=Angpart[angs,angles[[1;;;;astep]],rev]];

(*locator pane*)
Column[{
(*sclice buttons*)
Row[{Button["<<<",n=1],Button["<<", n=start],Button["<",n=n-1],
	Button[">",n=n+1],Button[">>",n=end],Button[">>>",n=slices]}]
,
(*locator pane *)
LocatorPane[
(*dynamic points*)
Dynamic[points[[n]]],
(*dynamic plot*)
Dynamic[Show[anatomypl,maskpl,polplot,lineplot,lineplot2,pointplot,circplot,centerpl[[n]]
(*,PlotLabel\[Rule]{segm,segments}*)]]
(*locator appearance*)
,Appearance->{Graphics[{Green,Disk[]},ImageSize->15],Graphics[{Blue,Disk[]},ImageSize->15]}
]
},Alignment->Center]
,
(*manipulate controls*)
{{n,Round[slices/2],"Slice"},1,slices,1},
{{mop,.2,"Mask opacity"},0,1},
{{masktype,True,"show lines mask"},{True->"threshold mask",False->"normal mask"}},
{{segmi,"AHA","Number of segments"},{1->"1 per sliec",4->"4 per slice",6->"6 per slice","AHA"->"AHA-17"},ControlType->SetterBar},
PaneSelector[{
False->"",
True-> Control[{{slcgrp,True,"Use slice grouping:"},{False->"group by slice",True->"group by region"},ControlType->SetterBar}]
},
Dynamic[NumberQ[segmi]]],
Delimiter,

(*point controls*)
Row[{
Button["Reverse points",rev=If[rev==1,-1,1];points=Reverse/@points,FrameMargins->0,Appearance->If[rev==-1,"Pressed","Normal"]],
Button["Reset points",points=pointsIn,FrameMargins->0],
Button["Rotate points -90",points=MapThread[{RotatePointC[#1[[1]],#2,-.5Pi],RotatePointC[#1[[2]],#2,-.5Pi]}&,{points,centers}],FrameMargins->0],
Button["Rotate points 90",points=MapThread[{RotatePointC[#1[[1]],#2,.5Pi],RotatePointC[#1[[2]],#2,.5Pi]}&,{points,centers}],FrameMargins->0]
}],

(*display controls*)
Delimiter,
{{display,{1,4},"display"},{1->"arrows",4->"disks",2->"lines",5->"lines mask",3->"points mask"},ControlType->TogglerBar},
{{mesh,False,"show gridlines"},{False,True}},
{{astep,3,"line resolution"},1,5,1},
{{linetr,OptionValue[LineThreshold],"line threshold"},0.1,1,.05},
Button["recalculate lines",lines=LinePoints[mask,off,LineThreshold->linetr,LineStep->OptionValue[LineStep]];],

Delimiter,
(*slice segmentation*)
Column[{
(*slices slider*)
Row[{
VerticalSlider[Dynamic[start],{0,slices,1},Background->Lighter@Gray, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[ap],{0,slices,1},Background->Lighter@Orange, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[mid],{0,slices,1},Background->Lighter@Blue, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[bas],{0,slices,1},Background->Lighter@Red, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[end],{0,slices,1},Background->Lighter@Purple, Appearance -> {Vertical, Tiny}],"      ",
Dynamic[Show[carPl,allpl]]
}]

}]
,
(*close buttons*)
Delimiter,
Row[{
DefaultButton["Done",DialogReturn[
{segmask, segang, points}=GenerateOutput[points,centers,segments(*[[1;;4]]*),rev,NumberQ[segmi],slcgrp,coordinates,Dimensions[mask],lines];

segang=Map[{#[[1]], DeleteCases[#[[2]], {}]} &, segang, {2}];

{segmask,segang, {{points,rev},{start,ap,mid,bas,end}}}
]],
CancelButton["Cancel",DialogReturn[$Canceled]]
}],

(*hidden controls*)
{{points,pointsIn},ControlType->None},
{angs,ControlType->None},
{angsp,ControlType->None},
{angsp2,ControlType->None},
{segpt,ControlType->None},
{segm,ControlType->None},
{segpts,ControlType->None},
{rad,ControlType->None},
{cent,ControlType->None},
{pols,ControlType->None},
{dsks,ControlType->None},
{pts,ControlType->None},
{{rev,revi},ControlType->None},
{{slcgrp,False},ControlType->None},

{{lmm,lm[[2]]},ControlType->None},

{{ap,api},ControlType->None},
(*{{app,api},ControlType->None},*)
{{mid,midi},ControlType->None},
{{bas,basi},ControlType->None},
{{end,endi},ControlType->None},
{{start,sti},ControlType->None},
{{allpl,allpli},ControlType->None},

{apex,ControlType->None},
{apical,ControlType->None},
{midcavity,ControlType->None},
{basal,ControlType->None},

{segments,ControlType->None},
{backcols,ControlType->None},
{backcol,ControlType->None},
{colls,ControlType->None},

{anatomypl,ControlType->None},
{maskpl,ControlType->None},
{polplot,ControlType->None},
{lineplot,ControlType->None},
{lineplot2,ControlType->None},
{pointplot,ControlType->None},
{circplot,ControlType->None},

(*initialization*)
(*Initialization:>{points=pointsIn},*)
ControlPlacement->Left,
SynchronousUpdating->True(*, SynchronousInitialization -> False*)
]
]
(*close dialog input*)
},WindowTitle->"Segement the heart",WindowFloating->True,Modal->True];


(* ::Subsubsection::Closed:: *)
(*ColFun*)


ColFun[i_,seg_,back_]:=If[back===Gray,back,If[seg==1,ColorData["Rainbow"][0.],ColorData["Rainbow"][((i-1)/(seg-1.))]]]

ColFun[i_,seg_]:=If[seg==1,ColorData["Rainbow"][0.],ColorData["Rainbow"][((i-1)/(seg-1.))]]


(* ::Subsubsection::Closed:: *)
(*RegionDisk*)


RegionDisk[cent_,ang_,ran_,rev_]:=Block[{ans},
ans=Partition[If[Negative[#],#+2Pi,#]&/@(-ang+0.5Pi),2,1,1];
If[rev==1,
Disk[cent,ran,If[#[[1]]>#[[2]],#,#+{0,-2Pi}]]&/@ans,
Disk[cent,ran,If[#[[2]]>#[[1]],Reverse@#,Reverse[#+{0,+2Pi}]]]&/@ans
]]


(* ::Subsubsection::Closed:: *)
(*RegionPoints*)


RegionPoins[cent_,angs_,points_]:=Block[{pts},
If[Length[angs]==1,
	{points},
	If[points==={},
		ConstantArray[{},Length[angs]]
		,
		pts=Partition[RotateRadC[5000,cent,#]&/@angs,2,1,1];
		Pick[points,RegionMember[Polygon[Prepend[#,cent]+0.5],points]]&/@pts
	]
]
]


(* ::Subsubsection::Closed:: *)
(*RadCalcC*)


RadCalcC=Compile[{{pnt,_Real,2},{cent,_Real,1}},Mean[Norm[#-cent]&/@pnt]];


(* ::Subsubsection::Closed:: *)
(*VecAngleC*)


VecAngleC=Compile[{{pnt,_Real,2},{cent,_Real,1},{num,_Real,0},{rev,_Real,0}},
Block[{x1,x2,y1,y2,ang1,ang2,angs,angs2,angsout,diff},
{{x1,y1},{x2,y2}}=(#-cent&/@pnt);
ang1=ArcTan[y1,x1];
ang2=ArcTan[y2,x2];
diff=If[rev==1,ang2-ang1,ang1-ang2];
diff=If[Negative[diff],2Pi+diff,diff];

angs={ang1,ang2,0.5 diff,0.25(2Pi- diff),1/3.(2Pi- diff)};

angs2=If[num==6,
{
angs[[1]]-(rev angs[[4]]),angs[[1]],
angs[[1]]+(rev angs[[3]]),angs[[2]],
angs[[2]]+(rev angs[[4]]),angs[[2]]+(rev 2 angs[[4]])}
,
If[num==4,
{
angs[[1]]-(rev angs[[5]]),angs[[1]],
angs[[2]],angs[[2]]+(rev angs[[5]])}
,
{angs[[1]]}
]
];
If[Negative[#],2Pi+#,#]&/@angs2
]];


(* ::Subsubsection::Closed:: *)
(*RotatePointC*)


RotatePointC=Compile[{{pt,_Real,1},{cent,_Real,1},{ang,_Real,0}},({{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}}.(pt-cent))+cent];


(* ::Subsubsection::Closed:: *)
(*RotateRadC*)


RotateRadC=Compile[{{rad,_Real,0},{cent,_Real,1},{ang,_Real,0}},(cent+{{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}}.{0,rad})];


(* ::Subsubsection::Closed:: *)
(*AngPart*)


Angpart[angs_,angles_,rev_]:=Block[{pang,end,start,sel},
pang=Partition[angs,2,1,1];
(
{start,end}=If[rev==1,#,Reverse@#];
If[start<end,
Select[angles ,start<#<=end&],
Select[angles ,#<=end||start<#&]
])&/@pang
]


(* ::Subsubsection::Closed:: *)
(*LinePoints*)


Options[LinePoints] = {LineThreshold -> .3, LineStep -> .75};

LinePoints[mask_, off_, OptionsPattern[]] := 
 Block[{int2D,dimy,dimx,step,angles,ii,vec,x,y,cent,points,points2,tresh,maskf,centv,first,val,vals,last},
  step = OptionValue[LineStep];
  {dimy, dimx} = Dimensions[First[mask]];
  angles = Table[RotationMatrix[-i Degree].{0., 1.}, {i, 0, 359, 1.}];
  tresh = OptionValue[LineThreshold];
  
  Table[
   maskf = N[GaussianFilter[mask[[n]], 2]];
   If[Total[Flatten[maskf]] < 2,
    (*if no maks do nothing*)
    ConstantArray[{}, Length[angles]]
    ,
    (*if mask find points*)
    int2D = ListInterpolation[maskf, InterpolationOrder -> 1];
    {x, y} = cent = off[[n, {3, 2}]];
    centv = Ceiling[int2D[y + 0.5, x + 0.5] - tresh];
    
    If[centv == 1,
     (*if cent is in mask*)
     first = cent;
     Map[(
        ii = 0; val = centv; vec = #; {x, y} = cent;
        (*find the first position for which point is outside the mask*)

        
        While[(1 + step <= y <= dimy - step - 1 && 
           1 + step <= x <= dimx - step - 1 && val > 0.),
         {x, y} = cent + (ii step) vec; 
         val = int2D[y + 0.5, x + 0.5] - tresh; ii++;
         ];
        last = cent + ((ii - 2) step) vec;
        (*if none found return {} else return cent and firt point*)
        If[val <= 0., {first, last}, {}]
        ) &, angles]
     ,
     (*if cent is in mask outside mask, firt find first edge*)
     Map[(
        ii = 0; val = centv; vec = #; {x, y} = cent;
        (*find the first position for which point is inside the mask*)

        
        While[(1 + step <= y <= dimy - step - 1 && 
           1 + step <= x <= dimx - step - 1 && val <= 0.),
         {x, y} = cent + (ii step) vec; 
         val = int2D[y + 0.5, x + 0.5] - tresh; ii++;
         ];
        first = cent + ((ii - 1) step) vec;
        (*Then find the first position for which point is outside the mask again*)
        While[(1 + step <= y <= dimy - step - 1 && 
           1 + step <= x <= dimx - step - 1 && val > 0.),
         {x, y} = cent + (ii step) vec; 
         val = int2D[y + 0.5, x + 0.5] - tresh; ii++;
         ];
        last = cent + ((ii - 2) step) vec;
        (*if none found return {} else return cent and firt point*)
        If[val <= 0, {first, last}, {}]
        ) &, angles]
     ]
    ](*close if*)
   , {n, 1, Length[mask], 1}](*close table*)
  
  ]


(* ::Subsubsection::Closed:: *)
(*GenerateOutput*)


GenerateOutput[points_,centers_,segments_,rev_,numSeg_,slcGrp_,coordinates_,dim_,lines_]:=Block[
{slices,segm,angs,cent,pts,dim2,sls,sgm,tmp,mask,ind,segang,
blank,msk,ptstmp,segmask,output,angles,angsp},
slices=dim[[1]];
dim2=Drop[dim,1];
segm=Flatten[Thread/@segments];
angles=Table[i,{i,0,359,1}]Degree;


(*create mask per slice from points*)
{segmask,segang}=Transpose@Table[
cent=centers[[n]];
angs= VecAngleC[points[[n]],cent,n/.segm,rev];

pts=RegionPoins[cent,angs,coordinates[[n]]];
angsp=Angpart[angs,angles,rev];
angsp=lines[[n,(#/Degree+1)]]&/@angsp;

(*Generate mask per sliec*)
blank=ConstantArray[ConstantArray[0,dim2],Length[pts]];
mask=MapThread[(
msk=#1;
ptstmp=#2;
(msk[[#[[2]],#[[1]]]]=1)&/@ptstmp;
msk
)&,{blank,pts}];
{mask,angsp}
,{n,1,slices,1}];

(*group mask slices for AHA 17 segments*)
segmask=If[!numSeg||slcGrp,
Flatten[Table[
sls=segments[[i,1]];
sgm=segments[[i,2]];
tmp=ConstantArray[0,Flatten[{sgm,dim}]];
If[sls==={},
tmp,
tmp[[All,sls]]=Transpose[segmask[[sls]]]
];
tmp
,{i,Length[segments],1,-1}],1]
,
Transpose@segmask

];

(*group radial coordinates for AHA 17 segments*)
segang=If[!numSeg||slcGrp,
Flatten[Table[
sls=segments[[i,1]];
sgm=segments[[i,2]];
If[sls==={},
ConstantArray[{},i/.{1->1,2->4,3->6,4->6}],
Transpose@MapThread[(
tmp=#1;
ind=#2;
{ind,#}&/@tmp
)&,{segang[[sls]],sls}]
]
,{i,Length[segments],1,-1}],1]
,
Transpose@MapIndexed[(
tmp=#1;
ind=First[#2];
{ind,#}&/@tmp)&,segang,1]
];
{segmask,segang,Reverse@points}
]


(* ::Subsection:: *)
(*PlotSegments*)


(* ::Subsubsection::Closed:: *)
(*PlotSegments*)


Options[PlotSegments] = {RadialSamples -> 10};

SyntaxInformation[PlotSegments] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotSegments[data_, mask_, angs_, OptionsPattern[]] := Block[{pan}, 
 	pan = Manipulate[ 		
 		slices=angs[[n,All,1]];
 		pts=DeleteCases[#,{}]&/@angs[[n,All,2]];
 		nmr=Range[Length[slices]];
 		
 		datpl=ArrayPlot[data[[#]], DataReversed -> True, ColorFunction -> "GrayTones"]&/@slices;
 		maskpl=mask[[slices]];
 		
 		size = Length[angs[[n]]] 250;
 		(*switch between views*)
 		GraphicsRow[Show[
 		Switch[m,
 			(*mask with inner and outer pionts only*) 
 			1, {datpl[[#]],
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ListPlot[{pts[[#,All,1]], pts[[#,All,2]]}, AspectRatio -> 1, PlotStyle -> {Red, Orange}],
 					Graphics[]
 				]},
 			(*mask with inner and outer points plus radial samples*)
 			2, {datpl[[#]],
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ListPlot[Transpose@PointRange[pts[[#]], OptionValue[RadialSamples]], AspectRatio -> 1],
 					Graphics[]
 				]},
 			3, {
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ArrayPlot[Fun[maskpl[[#]], Round[pts[[#,All,1]]], Round[pts[[#,All,2]]]], DataReversed -> True, ColorFunction -> "GrayTones"],
 					ArrayPlot[maskpl[[#]], DataReversed -> True, ColorFunction -> "GrayTones"]
 				]}
     		]
 		] &/@ nmr, ImageSize->size], 
	    {{n, 1, "segment"}, 1, Length[angs], 1}, 
	    {{m, 1, "plot type"}, {1 -> "start stop point", 2 -> "radial samples", 3 -> "mask"}}, 
	    {size, ControlType -> None},
	    {pts, ControlType -> None},
	    {nmr, ControlType -> None},
	    {slices, ControlType -> None},
	    {datpl, ControlType -> None},
	    {maskpl, ControlType -> None},
	    
	    SaveDefinitions->True
     ];
  NotebookClose[plotwindow];
  plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
  ]


(* ::Subsubsection::Closed:: *)
(*Fun*)


Fun[mask_,pts1_,pts2_]:=Block[{tmp=mask},
(tmp[[#[[2]],#[[1]]]]=10)&/@pts1;
(tmp[[#[[2]],#[[1]]]]=-10)&/@pts2;
tmp]


(* ::Subsubsection::Closed:: *)
(*PointRange*)


PointRange[pts_,steps_]:=Block[{step=steps-1,pt1,pt2},
(
pt1=#[[2,{1,2}]];
pt2=#[[1,{1,2}]];
Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}]
)&/@pts
]

PointRange[pts_,steps_,drop_]:=Block[{step=steps-1,pt1,pt2},
(
pt1=#[[2,{1,2}]];
pt2=#[[1,{1,2}]];
Take[Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}],{1+drop,steps-drop}]
)&/@pts
]

PointRangeC = 
  Compile[{{pts, _Real, 2}, {steps, _Integer, 0}, {drop, _Integer, 0}},
   Block[{step = steps - 1, pt1, pt2},
    pt1 = pts[[2]];
    pt2 = pts[[1]];
    Take[Table[
      pt2 + (i (pt1 - pt2)/step), {i, 0, step, 1}], {1 + drop, 
      steps - drop}]
    ], RuntimeAttributes -> {Listable}, Parallelization -> True, 
   RuntimeOptions -> "Speed"
   ];


(* ::Subsection::Closed:: *)
(*PlotSegmentsMask*)


SyntaxInformation[PlotSegmentMask] = {"ArgumentsPattern" -> {_, _, _}};

PlotSegmentMask[maski_, segmaski_, vox_] := Module[{heart, seg,pan},
  
  heart = PlotMaskVolume[maski, vox];
  seg = PlotMaskVolume[segmaski[[#]], vox, Red,Filter->False] & /@ 
    Range[Length[segmaski]];
  
  pan=Manipulate[
   GraphicsGrid[
    {
     {Show[heart, seg[[n]]],
      Show[heart, seg[[n]], ViewPoint -> Front, 
       Method -> {"RotationControl" -> None}]},
     {Show[heart, seg[[n]], ViewPoint -> Top, 
       Method -> {"RotationControl" -> None}],
      Show[heart, seg[[n]], ViewPoint -> Left, 
       Method -> {"RotationControl" -> None}]}
     }
    , ImageSize -> 600]
   , {{n,1,"Segment"}, 1, Length[segmaski], 1},SaveDefinitions->True];
  
  NotebookClose[plotwindow];
  plotwindow = 
   CreateWindow[
    DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, 
     WindowSize -> All, WindowTitle -> "Plot data window"]];
  
  ]


(* ::Subsection::Closed:: *)
(*RadialSample*)


Options[RadialSample]={RadialSamples->10, DropSamples->0};

SyntaxInformation[RadialSample] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RadialSample[mask_,data_,segang_,OptionsPattern[]]:=Block[{
infunc,maskm,dat,pos,val,output, intfunc,slice,pts,int,ptsr,vals},

(*slice by slice interpolation function*)
intfunc = MapThread[(
     pos = Position[Round[#1], 1];
     dat = #1 #2;
     val = dat[[#[[1]], #[[2]]]] & /@ pos;
     With[{
       intdat = N@Thread[{pos, val}],
       extdat = N@Thread[pos -> val]
       },
      If[!(pos === {}),
       Interpolation[intdat, InterpolationOrder -> 1, "ExtrapolationHandler"->{(Mean@Nearest[extdat, {#1, #2}, 3]) &, "WarningMessage" -> False}]]
      ]
     ) &, {mask, data}, 1];

(*generate output by radial sampleling segments*)
output=Map[(
slice=#[[1]];
pts=DeleteCases[#[[2]],{}];
int=intfunc[[slice]];

If[FreeQ[pts, {}],
(*get radial pts steps*)
ptsr=PointRangeC[pts,OptionValue[RadialSamples],OptionValue[DropSamples]]+0.5;
vals=int @@ Reverse[Transpose[ptsr, {2, 3, 1}]];
,
ptsr=vals={}];
{ptsr,vals}

)&,segang,{2}];

{output[[All,All,1]],output[[All,All,2]]}
]


(* ::Subsection::Closed:: *)
(*TransmuralPlot*)


Options[TransmuralPlot] = {GridLineSpacing -> 10, PlotStyle -> Red, PlotRange -> Automatic, ImageSize->300,Method->"Median",PlotLabel->None}

SyntaxInformation[TransmuralPlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

TransmuralPlot[data_, OptionsPattern[]] := 
 Block[{mn, std, steps, stdM, stdP, xdata, min, max, col,pdat,dat,fil,style},
  dat=If[ArrayDepth[data]==1,
  {data},
  Switch[OptionValue[Method],
  	"Median",
  	Transpose[Quantile[data, {.5, .35, .65}]],
  	"MedianSD",
  	Transpose[Quantile[data, {.5, .16, .84}]],
  	"Median95",
  	Transpose[Quantile[data, { .5, .05, .95}]],
  	"Median0",
  	Transpose[Quantile[data, {.5}]],
  	_,
	mn = Mean[data];
	std = StandardDeviation[data];
	{stdM, stdP} = {mn - std, mn + std};
	{mn,stdM,stdP}
	]
  ];
  
  steps = Length[dat[[1]]];
  xdata = (Range[0, steps - 1])/(steps - 1);
  pdat=(Thread[{xdata, #}]&/@ dat);
  
  fil=If[OptionValue[Method]=="Median0",None,{2 -> {3}}];
  
  {min, max} = If[OptionValue[PlotRange] === Automatic, MinMax[dat], OptionValue[PlotRange]];
 
 style=If[ArrayDepth[data]==1,
 	OptionValue[PlotStyle]
 	,
 	col = OptionValue[PlotStyle];
    (Directive[#, col,Thick] & /@ {Dashing[None], Dashed, Dashed})
 
 ];
  col = OptionValue[PlotStyle];
  ListLinePlot[pdat, PlotStyle ->style, 
  	Filling -> fil, FillingStyle -> Directive[Opacity[0.2], col],
   
   Axes -> False, Frame -> {{True, False}, {True, False}}, 
   FrameStyle -> Directive[{Thick, Black}], 
   LabelStyle -> Directive[{Bold, Black, 14, FontFamily -> "Helvetica"}],
   PlotRange -> {{0, 1}, {min, max}},ImageSize->OptionValue[ImageSize],PlotLabel->OptionValue[PlotLabel],
   GridLines -> {{{.5, Directive[Thick, Black, Dashed]}}, Join[System`FindDivisions[{min, max},Round[(max-min)/ OptionValue[GridLineSpacing]]], {{0, Directive[{Thick, Black}]}}]}, 
   FrameTicks -> {{{0, "Endo"}, {.5, "Mid"}, {1, "Epi"}}, Automatic}]
  ]


(* ::Subsection::Closed:: *)
(*MaskHelix*)


Options[MaskHelix]={BackgroundValue-> -100, SmoothHelix->False};

SyntaxInformation[MaskHelix] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

MaskHelix[helix_, mask_,OptionsPattern[]] := Block[{fun},
	fun=Switch[
		OptionValue[SmoothHelix],
		1, N[mask MedianFilter[#, 1]] /. 0. -> OptionValue[BackgroundValue],
		_, N[mask #] /. 0. -> OptionValue[BackgroundValue]
		]&;
	If[ArrayDepth[helix]==4,fun/@helix,fun[helix]]	
]


(* ::Subsection::Closed:: *)
(*BullseyePlot*)


Options[BullseyePlot]={TextOffset->.5,TextSize->12,PlotRange->Automatic, ColorFunction->"TemperatureMap", BullPlotMethod->"Dynamic",ImageSize->200};

SyntaxInformation[BullseyePlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

BullseyePlot[data_?ArrayQ,segMask_?ArrayQ,opts:OptionsPattern[]]:=Block[{fdata}, 
fdata=(Flatten@GetMaskData[data,#])&/@segMask;
BullseyePlot[fdata,opts]
]

BullseyePlot[dati_?ListQ,OptionsPattern[]]:=Block[{number, radius, datat, min, max, cols, sdata, pts, disks, 
  textv, textn, plfun, col},
 number = {6, 6, 4, 1};
 radius = {4.9, 3.6, 2.3, 1};
 datat = If[# === {} || NumberQ[#], #, Round[Mean[#], .01]] & /@ dati;
 
 {min, max} = 
  If[OptionValue[PlotRange] === Automatic, 
   MinMax[DeleteCases[datat, 0.]], OptionValue[PlotRange]];
 
 cols = (# -> 
      Show[ColorData[#, "Image"], 
       ImageSize -> 100]) & /@ {"GrayTones", "Rainbow", 
    "ThermometerColors", "SunsetColors", "TemperatureMap", 
    "GrayYellowTones", "BlueGreenYellow", "AvocadoColors", 
    "SouthwestColors"};
 
 max = If[max <= min, min + 0.1, max];
 sdata = (datat - min)/(max - min);
 
 pts = Flatten[
   Table[If[i == 4, {{0, 0}}, 
     RotationMatrix[# Degree].{0, 
         radius[[i]] - 1.3 OptionValue[TextOffset]} & /@ 
      Range[0, 359, 360/number[[i]]]], {i, 4}], 1];
 
 disks = Flatten[{
    Table[{col, Disk[{0, 0}, radius[[1]], Pi/3 {i, i + 1}]}, {i, 1, 
      6}],
    Table[{col, Disk[{0, 0}, radius[[2]], Pi/3 {i, i + 1}]}, {i, 1, 
      6}],
    Table[{col, 
      Disk[{0, 0}, radius[[3]], (i - 1) Pi/2 + {Pi/4, 3 Pi/4}]}, {i, 
      1, 4}],
    {{col, Disk[{0, 0}, radius[[4]], {0, 2 Pi}]}}
    }, 1];
 
 textv = Table[
   Text[Style[If[datat[[i]] === {} || sdata[[i]] < 0, "", datat[[i]]],
      Bold, FontFamily -> "Helvetica", Black, 
     FontSize -> OptionValue[TextSize]], pts[[i]]], {i, 17}];
 textn = Table[
   Text[Style[If[datat[[i]] === {} || sdata[[i]] < 0, "", i], Bold, 
     FontFamily -> "Helvetica", Black, 
     FontSize -> OptionValue[TextSize]], pts[[i]]], {i, 17}];
 
 plfun[{colf_, cstyle_}, {pText_, textVal_}] := 
  Block[{blcol, colfunc}, Legended[
    blcol = If[colf == "GrayTones", Darker[Red], Gray];
    colfunc = ColorData[colf][If[cstyle, 1 - #, #]] &;
    Graphics[{
      EdgeForm[{Thick, Black}], 
      MapThread[#1 /. 
         If[#2 === {} || #2 < 0, col -> blcol, 
          col -> colfunc[#2]] &, {disks, sdata}], 
      If[pText, Switch[textVal, 1, textn, 2, textv]]},
     ImageSize -> OptionValue[ImageSize]
     ], BarLegend[{colf, {min, max}}, 
     LabelStyle -> 
      Directive[{Bold, Black, FontFamily -> "Helvetica", 
        FontSize -> OptionValue[TextSize]}
       ], LegendMarkerSize -> 0.8 OptionValue[ImageSize]]]
   ];
 
 pan = Manipulate[
       plfun[{colf, cstyle}, {pText, textVal}]
       (*{{colf,cstyle},{pText,textVal}}*)
       ,
       {{pText, True, "Show labels"}, {True, False}},
       {{textVal, 2, "Label"}, {1 -> "Segment", 2 -> "Value"}},
       
       {{colf, OptionValue[ColorFunction], "Color function"}, cols},
       {{cstyle, False, "Reverse color"}, {True, False}},
       SaveDefinitions->True, Deployed->False, SynchronousInitialization -> False];
 
 If[OptionValue[BullPlotMethod] === "Dynamic",
  NotebookClose[plotwindow];
  plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
  ,
  plfun[{OptionValue[ColorFunction], False}, {True, 2}]
  ]
 ]


(* ::Subsection:: *)
(*ExcludeSlices*)


(* ::Subsubsection::Closed:: *)
(*ExcludeSlices*)


Options[ExcludeSlices] = {CutOffMethod -> "Auto",DistanceMeasure->5};

SyntaxInformation[ExcludeSlices] = {"ArgumentsPattern" -> {_, OptionsPattern[]}}

ExcludeSlices[data_, OptionsPattern[]] := 
 Block[{measure, selmask, cutoff, std, mn, bin, type,q1,q2,q3},
  type = OptionValue[DistanceMeasure];
  cutoff = OptionValue[CutOffMethod];
  (*get similarity measure*)
  measure = CalculateMeasure[data, type];
  (*calculate cutoff and selection mask*)
  cutoff = If[NumberQ[cutoff] && cutoff < .5,
    Quantile[Flatten@measure, cutoff],
    {q1, q2, q3} = Quantile[Flatten[measure], {0.25, 0.5, .75}];
	q2 - 2 (q3 - q1)
    ];
  selmask = Mask[measure, cutoff];
  (*report the outliers*)
  ShowOutlierDistribution[measure, selmask, cutoff];
  (*output mask*)
  selmask
  ]


(* ::Subsubsection::Closed:: *)
(*ShowOutlierDistribution*)


ShowOutlierDistribution[measure_, selmask_, cutoff_] := 
 Block[{mn, fmeas, minmax},
  fmeas = Flatten@measure;
  mn = Mean@fmeas;
  minmax = MinMax[fmeas];
  (*Plot Outlier distributions*)
  Print[GraphicsRow[{
     ListPlot[fmeas, GridLines -> {None, Flatten[{mn, cutoff}]}, 
      GridLinesStyle -> Directive@{Thick, Red}, 
      PlotStyle -> Directive@{PointSize[0.03], Black}, 
      PlotRange -> {All, minmax}],
     Histogram[fmeas, {(minmax[[2]] - minmax[[1]])/20}, 
      ChartStyle -> Black, PerformanceGoal -> "Speed", 
      GridLines -> {{mn, cutoff}, None}, 
      GridLinesStyle -> Directive@{Thick, Red}, 
      PlotRange -> {minmax, Full}]
     }, PlotLabel -> {mn, StandardDeviation[fmeas], cutoff}]];
  (*report outliers*)
  Print@Row[Flatten[
     {"% slices excluded: ", 
      Round[100 Total[Flatten[(1 - selmask)]]/
         Length[Flatten@selmask]], "  /  ",
      "% directions per slice exlcuded: ", 
      Round[100 (Total[(1 - #)]/Length[#] & /@ selmask)]}], "  "];
  ]


(* ::Subsubsection::Closed:: *)
(*CalculateMeasure*)


CalculateMeasure[data_, type_] := 
 Block[{target, datan, fun, measure, slice, dirs, mask,mm,q1,q2,q3,iqr},
	target = Median /@ data;
	target = Flatten /@ (target/Median[Flatten[target]]);
	datan = Map[Flatten[#/Median[Flatten[#]]] &, data, {2}];
  {slice, dirs} = Dimensions[datan][[1 ;; 2]];
  (*select distance measure*)
  fun = Switch[type,
    1, ManhattanDistance,
    2, SquaredEuclideanDistance,
    3, EuclideanDistance,
    4, Correlation,
    5, SpearmanRho,
    _, SpearmanRho];
  (*calculate measure*)
  measure = 
   Table[
   	mask=Unitize[target[[i]] datan[[i, j]]];
   	fun[Pick[target[[i]], mask, 1], Pick[datan[[i, j]], mask, 1]],
   	 {i, 1, slice, 1}, {j, 1, dirs, 1}];
  (*normalize measure*)
  measure = (
     mm = #;
     {q1, q2, q3} = Quantile[#, {0.25, 0.5, .75}];
     iqr = q3 - q1;
     mm = Select[mm, ((q1 - 1 iqr) < # < (q3 + 1 iqr)) &];
     {q1, q2, q3} = Quantile[mm, {0.25, 0.5, .75}];
     iqr = q3 - q1;
     mm = Select[mm, ((q1 - 1 iqr) < # < (q3 + 1 iqr)) &];
     {q1, q2, q3} = Quantile[mm, {0.25, 0.5, .75}];
     1 + (# - q2)/(10 (q3 - q1))
     ) & /@ measure;
  (*make low value bad*)
  If[type <= 3, 2 - measure, measure]
  ]


(* ::Subsection::Closed:: *)
(*MakeECVBloodMask*)


Options[MakeECVBloodMask] = {BloodMaskRange -> {1400, {0, 700}}, OutputCheckImage -> True}

SyntaxInformation[MakeECVBloodMask] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}}

MakeECVBloodMask[pre_, post_, OptionsPattern[]] := 
 Block[{mask1, mask2, bloodMask, meas, cent, preM, postM, slice, ims},
  {preM, postM} = OptionValue[BloodMaskRange];
  
  mask1 = Mask[pre, preM];
  mask2 = Mask[post, postM];
  
  bloodMask = 
   Image3D[ImageData[
       SelectComponents[Erosion[Image[#], 1], 
        "Count", -3]] & /@ (mask1 mask2)];
  meas = ComponentMeasurements[bloodMask, "IntensityCentroid"];
  
  cent = First@Nearest[meas[[All, 2]], Reverse@Dimensions[mask1]/2.];
  bloodMask = 
   Erosion[#, 1] & /@ 
    ImageData[
     SelectComponents[bloodMask, #IntensityCentroid == cent &]];
  
  If[OptionValue[OutputCheckImage],
   slice = Ceiling[Length[pre]/2];
   ims = (Image[((pre[[slice]]/Max[pre[[slice]]]) + 
         bloodMask[[slice]])/2]);
   {bloodMask, ims}
   ,
   bloodMask
   ]
  ]

  
(* ::Subsection::Closed:: *)
(*MakeECVBloodMask*)


ECVCalc[mappre_, mappost_, hema_?RealQ] := Block[{z, x, y, mask}, 
	mask = MakeECVBloodMask[mappre, mappost];
	ECVCalc[mappre, mappost, mask, hema]
]

ECVCalc[mappre_, mappost_, bloodMask_, hema_] := Block[{deltaR1, deltaR1b},
  deltaR1 = Clip[DevideNoZero[1, mappost] - DevideNoZero[1, mappre], {0, Infinity}];
  deltaR1b = Mean@Flatten[GetMaskData[deltaR1, bloodMask]];
  Clip[100 (deltaR1/deltaR1b) (1 - hema), {0, 100}]
]  


(* ::Subsection::Closed:: *)
(*CreateHeart*)


SyntaxInformation[CreateHeart] = {"ArgumentsPattern" -> {_.}};

CreateHeart[] := CreateHeart[0.]

CreateHeart[setin_] := Module[{set, col, contin, contout, shape, seto, shapeplot, 
   topline, shapeout, con, out, shapeoutC, shout, shin},
  set = out = If[setin === 0. || ! ListQ[setin],
     {{73, 2.85, 2.8, 0.018, 0}, {67, 3.42, 5.76, 0.078}, 110},
     setin
     ];
  col = Gray;
  
  NotebookClose[cardiacWindow];
  cardiacWindow = DialogInput[{
     CancelButton["Generate",
      DialogReturn[out = seto]
      ]
     ,
     Manipulate[
      contin = ContourPlot[With[
         {zi = 0.06 (zp - higi), xi = 0.06 (xp - 59), yi = 0},
         ((xi - shifti)^2/widthi*(1 - cupi zi) + (yi)^2/
             widthi*(1 - cupi zi) + zi^2/lengthi^2)
         ], {xp, 0, 120}, {zp, 0, 120}, Contours -> {1}, 
        ContourStyle -> {Thick, Red}, ContourShading -> None];
      contout = ContourPlot[With[
         {zo = 0.06 (zp - higo), xo = 0.06 (xp - 59), yo = 0},
         (xo^2/widtho*(1 - cupo zo) + yo^2/widtho*(1 - cupo zo) + 
           zo^2/lengtho^2)
         ], {xp, 0, 120}, {zp, 0, 120}, Contours -> {1}, 
        ContourStyle -> {Thick, Blue}, ContourShading -> None];
      
      shape = Table[
        With[{
          zi = 0.06 (zp - higi), xi = 0.06 (xp - 59.5), yi = 0,
          zo = 0.06 (zp - higo), xo = 0.06 (xp - 59.5), yo = 0},
         shout = 
          If[((xo^2/widtho*(1 - cupo zo) + yo^2/widtho*(1 - cupo zo) +
                zo^2/lengtho^2) > 1), 0, 1];
         shin = 
          If[(((xi - shifti)^2/widthi*(1 - cupi zi) + 
               yi^2/widthi*(1 - cupi zi) + zi^2/lengthi^2) > 1), 0, 1];
         shout - shin
         ], {zp, 120, 1, -1}, {xp, 1, 120}];
      (*shapef=shape;
      con=ConstantArray[0,Dimensions[shape]];
      shapef[[;;Length[shapef]-top+1]]=con[[;;Length[shapef]-
      top+1]];*)
      
      seto = {{higi, lengthi, widthi, cupi, shifti}, {higo, lengtho, 
         widtho, cupo}, top};
      
      shapeplot = ArrayPlot[shape];
      topline = 
       Graphics[{{Green, Thick, Line[{{0, top}, {120, top}}]}, {White,
           Polygon[{{0, top}, {120, top}, {120, 
             Length[shape] + 1}, {0, Length[shape] + 1}}]}}];
      Show[shapeplot, topline, contin, contout]
      
      , Delimiter
      , {{higi, set[[1, 1]], "inner hight"}, 60, 90}
      , {{lengthi, set[[1, 2]], "inner length"}, 2, 4}
      , {{widthi, set[[1, 3]], "inner width"}, 1, 10}
      , {{cupi, set[[1, 4]], "inner cup"}, 0, 0.25}
      , {{shifti, set[[1, 5]], "inner shift"}, -1, 1}
      , Delimiter
      , {{higo, set[[2, 1]], "outer hight"}, 60, 90}
      , {{lengtho, set[[2, 2]], "outer length"}, 2, 4}
      , {{widtho, set[[2, 3]], "outer width"}, 1, 10}
      , {{cupo, set[[2, 4]], "outer cup"}, 0, 0.25}
      , Delimiter
      , {{top, set[[3]],"top loation"}, 90, 120, 1}
      , Button["set 1",
       {{higi, lengthi, widthi, cupi}, {higo, lengtho, widtho, cupo}, 
         top} = {{73, 2.85, 2.8, 0.018}, {67, 3.42, 5.76, 0.078}, 110}]
      , Button[
       "set 2", {{higi, lengthi, widthi, cupi}, {higo, lengtho, 
          widtho, cupo}, 
         top} = {{69, 3.1, 2.8, 0.16}, {67.5, 3.6, 7.3, 0.12}, 105}],
      SynchronousUpdating -> True, Method -> "Queued"
      ]
     
     }, WindowSize -> All, WindowTitle -> "Plot data window", 
    WindowFloating -> True, Modal -> True];
  
  shapeoutC = Compile[{{seti, _Real, 1}, {seto, _Real, 1}}, Table[
     With[{
       zi = 0.06 (zp - seti[[1]]),
       xi = 0.06 (xp - 59.5),
       (*yi=0*)yi = 0.06 (yp - 59.5),
       zo = 0.06 (zp - seto[[1]]),
       xo = 0.06 (xp - 59.5),
       (*yo=0*)yo = 0.06 (yp - 59.5)},
      If[((xo^2/seto[[3]]*(1 - seto[[4]] zo) + 
            yo^2/seto[[3]]*(1 - seto[[4]] zo) + zo^2/seto[[2]]^2) > 
          1), 0, 1] -
       If[(((xi - seti[[5]])^2/seti[[3]]*(1 - seti[[4]] zi) + 
            yi^2/seti[[3]]*(1 - seti[[4]] zi) + zi^2/seti[[2]]^2) > 
          1), 0, 1]
      ], {zp, 1, 120, 1}, {xp, 1, 120, 1}, {yp, 1, 120, 1}]
    ];
  
  shapeout = shapeoutC[out[[1]], out[[2]]];
  con = ConstantArray[0, Dimensions[shapeout]];
  shapeout[[out[[3]] ;;]] = con[[out[[3]] ;;]];
  Return[{ArrayPad[shapeout, 10], {0.7, 0.7, 0.7}, seto}];
  ]
  

(* ::Subsection::Closed:: *)
(*CardiacCoordinateSystem*)


Options[CardiacCoordinateSystem] = {ShowFit -> False}

SyntaxInformation[CardiacCoordinateSystem] = {"ArgumentsPattern" -> {_,_, OptionsPattern[]}};

CardiacCoordinateSystem[mask_, vox_, OptionsPattern[]] := Block[
	{dim, wall,axesout,off, vec, inout,pla, plw, radvecn, norvec, norvecc, cirvec, der, sp, spz, spxy, maskCont,n ,vectorField,
	coo, rav, nov, rov, vec1, vec2, vec3, plot },
  dim = Dimensions[mask];
  (*Calculate the wall distance map, and the wall direction*)
  wall = CalculateWallMap[mask, vox, ShowFit -> OptionValue[ShowFit]];
  {wall, der} = 
   If[OptionValue[ShowFit], plw = wall[[3]]; wall[[1 ;; 2]], wall];
  
   (*get the cardiac center line*)
  axesout = 
   CentralAxes[mask, 0, vox, AxesMethod -> "Qubic", 
    ShowFit -> OptionValue[ShowFit]];
  {off, vec, inout} = 
   If[OptionValue[ShowFit], pla = axesout[[4]]; axesout[[1 ;; 3]], 
    axesout];
  
  (*create the cardaic coordinate system*)
  radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
  norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
  norvecc = MakePerpendicular[norvec, radvecn];
  cirvec = NormalizeC[CrossC[radvecn, norvecc]];
  
  (*plot hear geo*)
  sp = Round[Dimensions[mask]/{12, 24, 24}];
  sp = Round[Dimensions[mask]/{15, 30, 30}];
  {spz, spxy} = {sp[[1]], Min[sp[[2 ;; 3]]]};
  maskCont = PlotMaskVolume[mask, vox];
  n = (spz 0.6 vox[[1]]) {1, -1, 1}/vox;
  vectorField = Table[If[mask[[z, y, x]] == 0,
     {None, None, None},
     coo = {x, -y + dim[[2]] + 1, z};
     rav = Reverse[n radvecn[[z, y, x]]];
     nov = Reverse[n norvecc[[z, y, x]]];
     rov = Reverse[n cirvec[[z, y, x]]];
     {{Darker[Green], Thick, 
       Line[{coo(*-rav*), coo + rav}]}, {Darker[Blue], Thick, 
       Line[{coo(*-nov*), coo + nov}]}, {Darker[Red], Thick, 
       Line[{coo(*-rov*), coo + rov}]}}], {z, 1, dim[[1]], spz}, {y, 
     1, dim[[2]], spxy}, {x, 1, dim[[3]], spxy}];
  {vec1, vec2, vec3} = 
   DeleteCases[Flatten[#, 2], None] & /@ 
    Transpose[vectorField, {2, 3, 4, 1}];
  plot = Show[maskCont, Graphics3D[vec1], Graphics3D[vec2], 
    Graphics3D[vec3]];
  
  Print[plot];
  {radvecn, norvecc, cirvec}
  ]

(* ::Section:: *)
(*End Package*)


End[](* End Private Context *)

EndPackage[]
