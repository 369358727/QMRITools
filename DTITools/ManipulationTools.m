(* ::Package:: *)

(* ::Title:: *)
(*DTITools ManipulationTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["DTITools`ManipulationTools`", {"Developer`"}];
$ContextPath=Union[$ContextPath,System`$DTIToolsContextPaths];

Unprotect @@ Names["DTITools`ManipulationTools`*"];
ClearAll @@ Names["DTITools`ManipulationTools`*"];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection:: *)
(*Functions*)


RescaleData::usage = 
"RescaleData[data,dim] rescales image/data to given dimensions.
RescaleData[data,{vox1, vox2}] rescales image/data from size vox1 to size vox2."

Unwrap::usage = 
"Unwrap[data] unwraps the given dataset."

Correct::usage =
"Correct[data, phase, shiftpar] corrects the dataset data using the phasemap and the shiftpar and interpolation order 1.
Correct[data, phase, shiftpar, int] corrects the dataset data using the phasemap and the shiftpar and interpolation order int."

TensorCorrect::usage=
"TensorCorrect[tensor, phase, shift, vox] corrects the tensor based on B0 field map. Can perform both translation and rotation of tensor."

Deriv::usage = 
"Deriv[disp, vox] calculates the derivative of the displacement along the three main axes. disp is the displacement field, vox is the voxel size.
Deriv[disp, vox, mask] calculates the derivative of the displacement along the three main axes. Sharp edges between the background en disp are solved by the mask. mask is a mask delining the edge of the displacement field.";

JoinSets::usage =
"JoinSets[{dat1,dat2,...}, over] joins dat1, dat2, ... with over slices overlap.
JoinSets[{dat1,dat2,dat3...},{over1,over2,...}] joins dat1 and dat2 with over1 slices overlap, Joins dat2 and dat3 with over2 slices overlap and so on.
JoinSets[{dat1,dat2,...},{{over,drop1,drop2},...}] joins dat1, dat2 with over slices overlap and drops drop1 slices for dat1 and drop2 from drop 2."

TensMat::usage=
"TensMat[tensor] transforms tensor form vector format {xx,yy,zz,xy,xz,yz} to matrix format {{xx,xy,xz},{xy,yy,yz},{xz,yz,zz}}."

TensVec::usage=
"TensVec[tensor] transforms tensor form matrix format {{xx,xy,xz},{xy,yy,yz},{xz,yz,zz}} to vector format {xx,yy,zz,xy,xz,yz}."

GridDataPlot::usage = 
"GridDataPlot[{data1,data2,...}, part] makes a grid of multiple datasets with part sets on each row"

CropData::usage=
"CropData[data] creates a dialog window to crop the data (assumes voxsize (1,1,1)).
CropData[data,vox] creates a dialog window to crop the data."

ApplyCrop::usage=
"ApplyCrop[data,crop] aplies the corpped region obtained form CropData to the data.
ApplyCrop[data,crop,{voxorig,voxnew}] aplies the corpped region obtained form CropData to the data." 

TriggerGrid::usage=
"TriggerGrid[data, dyns, {{xmin, xmax}, {ymin, ymax}}]."

Data2DToVector::usage = 
"Data2DToVector[data] converst the data to vector.
Data2DToVector[data,mask] converst the data within the mask to vector.

the data can be reconstructed using VectorToData.

output is the vecotrized data and a list contining the original data dimensions and a list with the data coordinates. {vec, {dim,pos}}."

Data3DToVector::usage = 
"Data3DToVector[data] converst the data to vector..
Data3DToVector[data,mask] converst the data within the mask to vector.

the data can be reconstructed using VectorToData.

output is the vecotrized data and a list contining the original data dimensions and a list with the data coordinates. {vec, {dim,pos}}."

TransData::usage = 
"TransData[data,dir], dir is \"l\" or \"r\"."

VectorToData::usage = 
"VectorToData[vec, {dim,pos}] converts the vectroized data, using Data2DToVector or Data3DToVector, back to its original Dimensoins"

DriftCorrect::usage = 
"DriftCorrect[data, bval] dirft corrects the data using the signals of the lowest bvalue that has 6 or more unique volumes.
For the function to work optimal it is best to have these volumes evenly spread througout thet data \
and for the first and last volume to have this low bvalue." 

CutData::usage = 
"CutData[data] splits the data in two equal sets left and right."

StichData::usage =
"StichData[datal,datar] joins left and right part of the data generated by CutData."

DataTranformation::usage = 
"DataTranformation[data,vox,w] transforms a 3D dataset accordint to the affine transformation vector w"

InvertDataset::usage = 
"InvertDataset[data] inverts the data along the x y and z axes. In other words it is rotated aroud the origin such that (x,y,z)=(-x,-y,-z) and (0,0,0)=(0,0,0)"

SortDiffusionData::usage = 
"SortDiffusionData[data, grad, bval] sorts the diffusion datasets grad and bval for magnitude of bvalue."

RemoveIsoImages::usage = 
"RemoveIsoImages[data, grad, bval] Romoves the ISO images from the philips scanner from the data. ISO images have g={0,0,0} and b>0."

ConcatenateDiffusionData::usage=
"ConcatenateDiffusionData[{{data1, .., dataN}, {grad1, .., gradN}, {bval, .., bvalN}, {vox, .., voxN}}] concatenates the diffusion data sets.
ConcatenateDiffusionData[{data1, .., dataN}, {grad1, .., gradN}, {bval, .., bvalN}, {vox, .., voxN}] concatenates the diffusion data sets."


(* ::Subsection:: *)
(*Options*)


Kernel::usage = 
"Kernel is an option for DeNoise. Kernel can be \"Gaussian\", \"Disk\" or \"Box\"."

ReverseData::usage =
"ReverseData is an option for JoinSets. Reverses each individual datset given as input for the JoinSets function. True by default."

ReverseSets::usage =
"ReverseSets is an option for JoinSets. Reverses the order of the datsets, False by default."

MonitorUnwrap::usage = 
"MonitorUnwrap is an option for Unwrap and PhaseCalc. Monitor the unwrapping progress."

UnwrapDimension::usage = 
"UnwrapDimension is an option for Unwrap and PhaseCalc. Can be \"2D\" or \"3D\". 2D is for unwarpping 2D images or unwrapping the individual images from a 3D dataset \
(does not unwrap in the slice direction). 3D unwraps a 3D dataset in all dimensions."

RotationCorrect::usage =
"RotationCorrect is an option for TensorCorrect. Default is False. Is a tensor is deformed setting to True also the shear is accounted for by local rotation of the tensor"

DeNoiseIterations::usage = 
"DeNoiseIterations are the number of the denoising iterations."

MonitorDeNoise::usage = 
"MonitorDeNoise monitor the denoising progres."

NormalizeSignal::usage = 
"NormalizeSignal is an option for DriftCorrect."

CropOutput::usage = 
"CropOutput is an option for CropData, can be \"All\",\"Data\" or \"Crop\"."


(* ::Subsection:: *)
(*Error Messages*)


RescaleData::dim = "Given dimensions `1` not the same depth as that of the given data `2`."

RescaleData::data = "Error: Inpunt must be 2D with {xdim,ydim} input or 3D dataset with {xdim,ydim} or {zdim, xdim, ydim} input."

ApplyCrop::dim = "Crop region lies outside data range."

JoinSets::over = "Error: The overlap must be a number or a list which gives the overlap and how many slice must be droped. Not: `1`."

Unwrap::data2D = "Unwrapping Dimensions is 2D and this can only be preformed on 2D or 3D data. This data is `1`D."

Unwrap::data3D = "Unwrapping Dimensions is 3D and this can only be preformed on 3D data. This data is `1`D."

Unwrap::dim = "Unwrapping Dimensions can be \"2D\" or \"3D\", current value is `1`."

Data2DToVector::dim = "Data should be 2D or 3D, data is `1`D."

Data2DToVector::mask = "Data and mask should have the same dimensions: data `1` and mask `2`"

Data3DToVector::dim = "Data should be 3D or 4D, data is `1`D."

Data3DToVector::mask = "Data and mask should have the same dimensions: data `1` and mask `2`"

ConcatenateDiffusionData::dim= "data, grad and bval should be the same length:  data `1` / grad `2` / bval `2`"


(* ::Section:: *)
(*Functions*)


Begin["`Private`"] 


(* ::Subsection::Closed:: *)
(*ConcatenateDiffusionData*)


SyntaxInformation[ConcatenateDiffusionData] = {"ArgumentsPattern" -> {_, _., _., _.}};

ConcatenateDiffusionData[data_?ListQ] :=If[Length[data] == 4,ConcatenateDiffusionData[data[[1]], data[[2]], data[[3]], data[[4]]]]

ConcatenateDiffusionData[data_, grad_, val_, vox_] := 
  Module[{dataout, gradout, valout, voxout},
   If[Length[data] == Length[grad] == Length[val],
    dataout = Transpose@Flatten[Transpose[NormalizeDiffData[#]] & /@ data, 1];
    gradout = Flatten[grad, 1];
    valout = Flatten[val];
    
    {dataout, gradout, valout} = RemoveIsoImages[dataout, gradout, valout];
    {dataout, gradout, valout} = SortDiffusionData[dataout, gradout, valout];
    ,
    Return[Message[ConcatenateDiffusionData::dim, Length[data],Length[grad], Length[val]]];
    ];
   
   voxout = If[ListQ[vox] && ! ListQ[vox[[1]]], vox, vox[[1]]];
   
   {dataout, gradout, valout, voxout}
   ];


(* ::Subsection::Closed:: *)
(*SortDiffusionData*)


SyntaxInformation[SortDiffusionData] = {"ArgumentsPattern" -> {_, _, _}};

SortDiffusionData[data_, grad_, val_] := Module[{pos, valu, sel},
  {valu, pos} = UniqueBvalPosition[val];
  sel = Flatten[pos];
  {data[[All, sel]], grad[[sel]], val[[sel]]}
  ]


(* ::Subsection::Closed:: *)
(*RemoveIsoImages*)


SyntaxInformation[RemoveIsoImages] = {"ArgumentsPattern" -> {_, _, _}};

RemoveIsoImages[data_, grad_, val_] := Module[{sel},
  sel = Complement[Range[Length[val]], 
    Complement[Flatten[Position[grad, {0., 0., 0.}]], 
     Flatten[Position[val, 0.]]]];
  {data[[All, sel]], grad[[sel]], val[[sel]]}
  ]


(* ::Subsection::Closed:: *)
(*CropData*)


Options[CropData] = {CropOutput -> "All"};

SyntaxInformation[CropData] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

CropData[data_, vox : {_?NumberQ, _?NumberQ, _?NumberQ} : {1, 1, 1}, OptionsPattern[]] :=
  Block[{a, b, c, d, e, f, clipall, dd, dataout,output},
   
   dd = ArrayDepth[data];
   NotebookClose[cropwindow];
   
   DynamicModule[{outp, size, dat, zd, xd, yd, r1, r2, r3},
    
    Switch[dd, 4, dat = data[[All, 1]], 3, dat = data, _, Return[]];
    
    {zd, xd, yd} = Dimensions[dat];
    clipall = Ceiling[{0.5, zd - 0.5, 0.5, xd - .5, 0.5, yd - .5}];
    
    r1 = (vox[[2]]*xd)/(vox[[3]]*yd);
    r2 = (vox[[1]]*zd)/(vox[[3]]*yd);
    r3 = (vox[[1]]*zd)/(vox[[2]]*xd);
    
    size = Min[{r1, r2, r3}] 400;
    
    cropwindow = DialogInput[
      {
       DefaultButton[],

       Manipulate[
        outp = Ceiling[{zmin, zmax, xd - xmax, xd - xmin, ymin, ymax}];
        Grid[
         {{
           LocatorPane[Dynamic[{{ymin, xmax}, {ymax, xmin}}],
            
            Show[ArrayPlot[dat[[z]], ColorFunction -> "GrayTones", 
              Frame -> False, AspectRatio -> r1, 
              ImageSize -> size/r2], 
             Graphics[{Red, Thick, 
               Dynamic[
                Line[{{ymin, xmin}, {ymin, xmax}, {ymax, xmax}, {ymax,
                    xmin}, {ymin, xmin}}]], Green, 
               Line[{{y - 0.5, -10}, {y - 0.5, xd + 10}}], Blue, 
               Line[{{-10, xd - x + 0.5}, {yd + 10, xd - x + 0.5}}], 
               Red, Dynamic[
                Circle[Mean[{{ymin, xmin}, {ymax, xmax}}], 2]]}], 
             PlotRange -> {{0, yd}, {0, xd}}], {{0.5, 0.5}, {yd - 0.5,
               xd - 0.5}}, 
            Appearance -> Graphics[{Red, Disk[]}, ImageSize -> 10]]
           }, {
           LocatorPane[Dynamic[{{ymin, zmax}, {ymax, zmin}}],
            
            Show[ArrayPlot[Reverse[dat[[All, x]]], 
              ColorFunction -> "GrayTones", Frame -> False, 
              AspectRatio -> r2, ImageSize -> size/r2], 
             Graphics[{Blue, Thick, 
               Dynamic[
                Line[{{ymin, zmin}, {ymin, zmax}, {ymax, zmax}, {ymax,
                    zmin}, {ymin, zmin}}]], Green, 
               Line[{{y - 0.5, -10}, {y - 0.5, zd + 10}}], Red, 
               Line[{{-10, z - 0.5}, {yd + 10, z - 0.5}}], Blue, 
               Dynamic[
                Circle[Mean[{{ymin, zmin}, {ymax, zmax}}], 2]]}], 
             PlotRange -> {{0, yd}, {0, zd}}], {{0.5, 0.5}, {yd - 0.5,
               zd - 0.5}}, 
            Appearance -> Graphics[{Blue, Disk[]}, ImageSize -> 10]]
           ,
           LocatorPane[Dynamic[{{xmin, zmax}, {xmax, zmin}}],
            
            Show[ArrayPlot[Reverse /@ Reverse[dat[[All, All, y]]], 
              ColorFunction -> "GrayTones", Frame -> False, 
              AspectRatio -> r3, ImageSize -> size/r3], 
             Graphics[{Green, Thick, 
               Dynamic[
                Line[{{xmin, zmin}, {xmin, zmax}, {xmax, zmax}, {xmax,
                    zmin}, {xmin, zmin}}]], Blue, 
               Line[{{x - 0.5, -10}, {x - 0.5, zd + 10}}], Red, 
               Line[{{-10, z - 0.5}, {xd + 10, z - 0.5}}], Green, 
               Dynamic[
                Circle[Mean[{{xmin, zmin}, {xmax, zmax}}], 2]]}], 
             PlotRange -> {{0, xd}, {0, zd}}], {{0.5, 0.5}, {xd - 0.5,
               zd - 0.5}}, 
            
            Appearance -> 
             Graphics[{Green, Disk[]}, ImageSize -> 10]]}}, 
         Spacings -> 0],
        {{z, Round[zd/2], "slice"}, 1, zd, 1},
        {{x, Round[xd/2], "row"}, 1, xd, 1},
        {{y, Round[yd/2], "column"}, 1, yd, 1},
        {{xmin, 0.5}, 1, xmax - 1, ControlType -> None},
        {{xmax, xd - 0.5}, xmin + 1, xd, ControlType -> None},
        {{ymin, 0.5}, 1, ymax - 1, ControlType -> None},
        {{ymax, yd - 0.5}, ymin + 1, yd, ControlType -> None},
        {{zmin, 0.5}, 1, zmax - 1, ControlType -> None},
        {{zmax, zd - 0.5}, zmin + 1, zd, ControlType -> None},
SynchronousUpdating->True
        
        ]
       
       }, WindowTitle -> "Crop the data and press done", 
      WindowFloating -> True, Modal -> True
      ];

dataout =If[!(OptionValue[CropOutput] === "Clip"),
{a, b, c, d, e, f} = outp;
 If[dd == 3, 
data[[a ;; b, c ;; d, e ;; f]], 
data[[a ;; b, All, c ;; d, e ;; f]]
]
];
output=Switch[OptionValue[CropOutput],
"All",{dataout, outp},
"Data",dataout,
"Clip",outp];
];
Return[output]
]


(* ::Subsection::Closed:: *)
(*ApplyCrop*)


SyntaxInformation[ApplyCrop] = {"ArgumentsPattern" -> {_, _, _.}};

ApplyCrop[data_, crop_] := ApplyCrop[data, crop , {0,0}]

ApplyCrop[data_, crop_ , {v1_,v2_}] := Module[{z1, z2, x1, x2, y1, y2,dim},
	
	dim=Dimensions[data];
	dim=If[Length[dim]==4,dim[[{1,3,4}]],dim];
	
	{z1, z2, x1, x2, y1, y2} = If[v1===0&&v2===0,
		crop,
		Round[(crop - 1) Flatten[Transpose[ConstantArray[v2/v1, 2]]] + 1]
	];
	
	If[z1<1||z2>dim[[1]]||x1<1||x2>dim[[2]]||y1<1||y2>dim[[3]],Return[Message[ApplyCrop::dim]]];
		
  If[ArrayDepth[data] === 4,
   data[[z1 ;; z2, All, x1 ;; x2, y1 ;; y2]],
   If[ArrayDepth[data] === 3,
    data[[z1 ;; z2, x1 ;; x2, y1 ;; y2]],
    If[ArrayDepth[data] === 2,
     data[[x1 ;; x2, y1 ;; y2]]
     ]]]]



(* ::Subsection::Closed:: *)
(*Rescale Data*)


Options[RescaleData] = {InterpolationOrder -> 3};

SyntaxInformation[RescaleData] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

RescaleData[data_?ArrayQ, {v1_?VectorQ, v2_?VectorQ}, opts : OptionsPattern[]] := RescaleDatai[data, v1/v2, "v", opts]

RescaleData[data_?ArrayQ, dim_?VectorQ, opts : OptionsPattern[]] := RescaleDatai[data, dim, "d", opts]

Options[RescaleDatai] = {InterpolationOrder -> 3};

RescaleDatai[data_?ArrayQ, sc_?VectorQ, met_, 
  opts : OptionsPattern[]] := Block[{type, dim, int},
  dim = Dimensions[data];
  int = OptionValue[InterpolationOrder];
  
  Switch[ArrayDepth[data],
   (*rescale an image*)
   2,
   If[Length[sc] != 2,
    Return[Message[RescaleData::dim, sc, Dimensions[data]]];,
    RescaleImgi[data, {sc, met}, int]
    ],
   3(*rescale a 3D dataset*),
   Switch[Length[sc],
    2(*rescale a stac of 2D images*),
    RescaleImgi[#, {sc, met}, int] & /@ data,
    3(*rescale 3D data*),
    RescaleImgi[data, {sc, met}, int],
    _,
    Return[Message[RescaleDataInt::dim, sc, Dimensions[data]]];
    ],
   4(*rescale a 4D dataset, treat data as multiple 4D sets*),
   Transpose[RescaleDatai[#, sc, met, opts] & /@ Transpose[data]],
   _,
   Return[Message[RescaleDataInt::data]];
   ]
  ]

RescaleImgi[dat_, {sc_, met_}, n_] := Block[{type, im, dim},
  (*data type*)
  type = If[ArrayQ[dat, _, IntegerQ], "Bit16", "Real32"];
  dim = If[met == "v", Round[sc Dimensions[dat]], sc];
  (*convert to 2D or 3D image*)
  im = Switch[ArrayDepth[dat], 2, Image[dat, type], 3, Image3D[dat, type]];
  ImageData[ImageResize[im, Reverse[dim], Resampling ->{"Spline", n},Padding->0], type]
  ]


(* ::Subsubsection::Closed:: *)
(*GridData*)


SyntaxInformation[GridDataPlot] = {"ArgumentsPattern" -> {_, _}};

GridDataPlot[data_, part_] := Block[{dim, temp, adepth},
	adepth = ArrayDepth[data[[1]]];
	dim = Dimensions[data];
	dim[[1]] = dim[[1]] + (part - (Mod[Length[data], part] /. 0 -> part));
	temp = Transpose[Partition[PadRight[data, dim], part]];
	temp = MapThread[Join, #, adepth - 2] & /@ temp;
	temp = MapThread[Join, temp, adepth - 1]
  ]


(* ::Subsubsection::Closed:: *)
(*TriggerGrid*)


SyntaxInformation[TriggerGrid] = {"ArgumentsPattern" -> {_, _, _}};

TriggerGrid[data_, dyns_, {{r11_, r12_}, {r21_, r22_}}] := 
 Module[{tmp1, tmp1b, tmp2},
  tmp1 = Partition[Transpose[data[[All, All, r11 ;; r12, r21 ;; r22]]], 4];
  tmp1b = Map[N[#/Mean[Flatten[#]]] &, tmp1, {3}];
  tmp2 = Flatten[Flatten[Transpose[tmp1b, {1, 3, 2, 4, 5}], {2, 3}],1];
  GridDataPlot[tmp2, dyns]
  ]


(* ::Subsection:: *)
(*Phase unwrap*)


(* ::Subsubsection::Closed:: *)
(*Unwrap*)


Options[Unwrap]={MonitorUnwrap->True,UnwrapDimension->"2D"};

SyntaxInformation[Unwrap] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

(* Phase unwrapping algorithem based on M.A. Herraez et al 2002 and Abdul-Rahman 2007.
unwraping algorithem. Unwraps one image, needs functions: Diff, SecDiff, EdgeReliability and PairCoor*)

Unwrap[dat_,OptionsPattern[]]:=
Module[{data,step,undim,out,mon},
	
	undim=OptionValue[UnwrapDimension];
	mon=OptionValue[MonitorUnwrap];
	
	Switch[undim,
		"2D",
		data=dat//N;
		If[MatrixQ[data],
			If[mon,Print["Unwrapping one image using 2D algorithm."]];
			out=Unwrap2Di[data];,
			If[ArrayQ[data,3],
				If[mon,Print["Unwrapping ",Length[data]," images using 2D algorithm"]];
					Monitor[
						out=UnwrapZi[MapIndexed[(step=First[#2];Unwrap2Di[#1])&,data,{ArrayDepth[data]-2}]];
					,If[mon,ProgressIndicator[step, {0, Length[data]}],""]
					]
				,
				Message[Unwrap::data2D,ArrayDepth[data]]
				]
			];,
		"3D",
		data=N[ArrayPad[dat,1]];
		If[ArrayQ[data,3],
			If[mon,Print["Unwrapping 3D data using 3D algorithm"]];
			out=ArrayPad[Unwrap3Di[data,mon],-1];
			,
			Message[Unwrap::data3D,ArrayDepth[data]]
			];,
		_,
		Message[Unwrap::dim,undim]
		];
	Return[out]
	]


(* ::Subsubsection::Closed:: *)
(*UnwrapZi*)


UnwrapZi[data_]:=
Module[{
	Roundi=Module[{num2,tresh=.75},
	If[Negative[#],
		num2=#-Ceiling[#];
		If[-1<num2<-tresh,Floor[#],Ceiling[#]],
		num2=#-Floor[#];
		If[1>num2>tresh,Ceiling[#],Floor[#]]
		]
		]&,mask,slice,diff,meandiff,steps,off,unwrap,dat},
	mask=Unitize[data];
	slice=Round[0.5Length[data]];
	diff=(#[[1]]-#[[2]]&/@ Partition[data/(2Pi),2,1]);
	meandiff=Median[#]&/@ Map[DeleteCases[Flatten[N[#]],0.]&,diff];
	steps=FoldList[Plus,0,Map[Roundi[#]&,meandiff]];
	off=Round[Median[DeleteCases[Flatten[N[data[[slice]]/(2Pi)]],0.]]];
	unwrap=steps-(steps[[slice]]+off);
	dat=(2Pi unwrap+data)mask//N
	]


(* ::Subsubsection::Closed:: *)
(*Unwrapi2D*)


Unwrap2Di[dat_] := Module[{data, dim, DD, edges, groupnr, sorted, dati, x1, y1, x2, y2, 
	group1, group2, wrap, mask, groupsize, pos, const, g1, g2, max, groups, clustnr, part},
  
  (*rescale the dat to integers allows for faster matrix replacements*)
  data = Round[100000*ArrayPad[dat , 1]/(2 Pi // N)];
  mask = Clip[Ceiling[Abs[Chop[data]]], {0, 1}] // N;
  dim = Dimensions[data];
  
  (*Calculated the second oreder difference for each voxel and the edge reliability and order*)
  DD = SecDiff[data];
  edges = EdgeReliability[DD] // N;
  sorted = Sort[Flatten[MapIndexed[If[#1 != 0, {#1, #2}, Nothing] &, edges, {3}], 2]];
  
  (*define pre clusters for the data and asign group numbers to large clusters*)
  part = Partition[Range[Min[data], Max[data], Total@Abs@MinMax[data]/9] // N, 2, 1];
  dati = Mask[data /. 0 -> -150000, #] & /@ part;
  max = 1;
  
  groups = Total[(
  	clustnr = # (max + MorphologicalComponents[DeleteSmallComponents[Image[#]]]);
  	max = Max[{max, Max[clustnr]}];
  	clustnr
  	) & /@ dati];
  
  const = ConstantArray[0, dim];
  groupsize = SparseArray[Flatten[const]];

  With[{CCount = Compile[{{datac, _Integer, 2}, {x, _Integer, 0}}, Count[datac, x, 2]]}, 
  	(groupsize[[#]] = CCount[groups, #]) & /@ Range[1, Max[groups]]
  	];
  	
  groupnr = Max[groups];

  (*unwrapping algorithm*)
  With[{
    Wrap = Compile[{{x, _Integer, 0}, {y, _Integer, 0}}, Round[(x - y), 100000]],
    CPosition = Compile[{{x, _Integer, 2}, {n, _Integer, 0}}, Position[x, n]]
    },
   Map[
     (
       (*#[[1]]= direction, #2[[2]]=x, #[[3]]=y*)
       {x1, y1} = {#[[2]], #[[3]]};
       {x2, y2} = {#[[2]], #[[3]]} + {{0, 1}, {1, 0}}[[#[[1]]]];
       group1 = groups[[x1, y1]];
       group2 = groups[[x2, y2]];
       
       (*unwrapping logic*)
       (*1. both already in same group (most cases 60%)*)
       If[! group1 == group2 != 0,
        (*If not in the same group determine the wrap of the edge and determine how to unwrap*)
        wrap = Wrap[data[[x1, y1]], data[[x2, y2]]];
        (*2. one of two pixels already in group (second most cases 30%)*)
        If[(group1 == 0 && group2 != 0) || (group2 == 0 && group1 != 0),
         group1=group1+group2;
         groups[[x2, y2]] = group1;
         groupsize[[group1]] += 1;
         If[wrap != 0, data[[x2, y2]] += wrap];
         ,
         (*3. both belong to no group (third most cases 6%)*)
         If[group1 == group2 == 0,
           (*unwrap right or botom pixel and assign both to group*)
           groupnr++;
           groups[[x1, y1]] = groups[[x2, y2]] = groupnr;
           groupsize[[groupnr]] = 2;
           If[wrap != 0, data[[x2, y2]] += wrap];
           ,
           (*4. both already in a group (least cases 4%) (group1 != group2 !=0)*)
           (*Detrimine group sizes and check which group is larger*)
           If[(g1 = groupsize[[group1]]) >= (g2 = groupsize[[group2]]),
             (*group 1 is greather than or eaqual to group 2, add group 2 to group 1*)
             (*unwrap group 2 with respect to group 1,only do if wrap!= 0*)
             pos = CPosition[groups, group2];
             If[wrap != 0, data += ReplacePart[const, pos -> wrap]];
             groups = ReplacePart[groups, pos -> group1];
             groupsize[[group1]] += g2;
             groupsize[[group2]] = 0;
             ,
             (*group 2 is greather than or eaqual to group 1, add group 1 to group 2*)
             (*unwrap group 1 with respect to group 2,only do if wrap!= 0*)
             pos = CPosition[groups, group1];
             If[wrap != 0, data -= ReplacePart[const, pos -> wrap]];
             groups = ReplacePart[groups, pos -> group2];
             groupsize[[group2]] += g1;
             groupsize[[group1]] = 0;
             ];
           ];
         ];
       ];) &, sorted[[All,2]]
     ];
   ];
  Return[(((2 Pi)*ArrayPad[mask*data, -1]// N)/100000.)]
  ]


(* ::Subsubsection::Closed:: *)
(*Unwrapi3D*)


Unwrap3Di[dat_, mon_] := Module[{data, dim, ii, DD, groupnr, sorted, z1, x1, y1, z2, x2, y2, group1, group2, 
	wrap, mask, edges, groups, pos, groupsize, g1, g2, const, max, clustnr, dati, part},
  
  (*convert data to integers for fast matrix clacluations*)
  data = ToPackedArray[Round[100000*ArrayPad[dat , 1]/(2 Pi // N)]];
  mask = Clip[Ceiling[Abs[Chop[data]]], {0, 1}] // N;
  dim = Dimensions[data];
  
  (*monitor claculation*)
  If[mon, Print["Calculating edge reliability and sorting edges: ", DateString["Time"]]];
  (*calculate second order difference for voxels and the reliability of the edges and order*)
  DD = SecDiff[data];
  edges = EdgeReliability[DD];
  sorted = Sort[Flatten[MapIndexed[If[#1 != 0, {#1, #2}, Nothing] &, edges, {4}], 3]];
  
  (*Monitor calculation*)
  If[mon, Print["Preclustering data: ", DateString["Time"]]];
  (*precluster the data and asign large clusters to groups*)
  part = Partition[Range[Min[data], Max[data], Total@Abs@MinMax[data]/9] // N, 2, 1];
  dati = Mask[data /. 0 -> -150000, #] & /@ part;
  max = 1;
  
  groups = Total[(
  	clustnr = # (max + MorphologicalComponents[DeleteSmallComponents[Image3D[#]]]);
  	max = Max[{max, Max[clustnr]}];
  	clustnr
  	) & /@ dati];
  groupnr = Max[groups];
  
  const=ConstantArray[0,dim];   
  groupsize = SparseArray[Flatten[const]];
  
  With[{CCount = Compile[{{datac, _Integer, 3}, {x, _Integer, 0}}, Count[datac, x, 3]]},
  	(groupsize[[#]] = CCount[groups, #]) & /@ Range[1, Max[groups]]];
  
  (*monitor calculation*)
  If[mon,  Print["Unwrapping: ",DateString["Time"]]];
  ii = 0;
  Monitor[
  
  (*actual unwrapping algorithm*)
  With[{
    Wrap = Compile[{{x, _Integer, 0}, {y, _Integer, 0}}, Round[(x - y), 100000]],
    CPosition = Compile[{{x, _Integer, 3}, {n, _Integer, 0}}, Position[x, n]]
    },
   Map[(
       (*#[[1]]=direction, #[[2]]=x, #[[3]]=y*)
       ii ++;(*for monitoring*)
       {z1, x1, y1} = {#1[[2]], #1[[3]], #1[[4]]};
       {z2, x2, y2} = {#1[[2]], #1[[3]], #1[[4]]} + {{1, 0, 0}, {0, 0, 1}, {0, 1, 0}}[[#[[1]]]];
       group1 = groups[[z1, x1, y1]];
       group2 = groups[[z2, x2, y2]];
       
       (*unwrapping logic*)
       (*1. both already in same group (most cases 60%) do nothing*)
       If[! (group1 == group2 != 0),
        (*If not in the same group determine the wrap of the edge and determine how to unwrap*)
        wrap = Wrap[data[[z1, x1, y1]], data[[z2, x2, y2]]];     
        (*2. one of two pixels already in group (second most cases 30%)*)
        If[(group1 == 0 && group2 != 0) || (group2 == 0 && group1 != 0),
         group1=group1+group2;
         groups[[z2, x2, y2]] = group1;
         groupsize[[group1]] += 1;
         If[wrap != 0, data[[z2, x2, y2]] += wrap];
         ,
         (*3. both belong to no group (third most cases 6%)*)
         If[group1 == group2 == 0,
           (*unwrap right or botom pixel and assign both to group*)
           groupnr++;
           groups[[z1, x1, y1]] = groups[[z2, x2, y2]] = groupnr;
           groupsize[[groupnr]] = 2;
           If[wrap != 0, data[[z2, x2, y2]] += wrap];
           ,
           (*4. both already in a group (least cases 4%) (group1 != group2!=0)*)
	       (*Detrimine group sizes and check which group is larger*)
	       If[(g1 = groupsize[[group1]]) >= (g2 = groupsize[[group2]]),
	         (*group 1 is greather than or eaqual to group 2, add group 2 to group 1*)
	         (*unwrap group 2 with respect to group 1,only do if wrap!= 0*)
	         pos = CPosition[groups, group2];
	         If[wrap != 0, data += ReplacePart[const, pos -> wrap]];
	         groups = ReplacePart[groups, pos -> group1];
	         groupsize[[group1]] += g2;
	         groupsize[[group2]] = 0;
	         ,
	         (*group 2 is greather than or eaqual to group 1, add group 1 to group 2*)
	         (*unwrap group 1 with respect to group 2,only do if wrap!=0*)
	         pos = CPosition[groups, group1];
	         If[wrap != 0, data -= ReplacePart[const, pos -> wrap]];
	         groups = ReplacePart[groups, pos -> group2];
	         groupsize[[group2]] += g1;
	         groupsize[[group1]] = 0;
	         ];
           ];
         ];
	   ];) &, sorted[[All, 2]]
     ];
   ];
   ,ProgressIndicator[ii,{0,Length[sorted]}]
  ];
   
  If[mon, Print["Done: ", DateString["Time"]]];
  Return[((2 Pi)*ArrayPad[mask*data, -1]/100000) // N]
  ]


(* ::Subsubsection::Closed:: *)
(*EdgeReliability*)


EdgeReliability[dat_] :=
 Switch[ArrayDepth[dat],
  2(*2D data*),{
  	ArrayPad[ArrayPad[RotateLeft[#] & /@ dat + dat, {{0, 0}, {0, -1}}], {{1, 1}, {1, 2}}], 
    ArrayPad[ArrayPad[RotateLeft[dat] + dat, {{0, -1}, {0, 0}}], {{1, 2}, {1, 1}}]},
  3(*3D data*),{
   ArrayPad[ArrayPad[RotateLeft[dat] + dat, {{0, -1}, {0, 0}, {0, 0}}], {{1, 2}, {1,1}, {1, 1}}],
   ArrayPad[ArrayPad[(RotateLeft[#] & /@ #) & /@ dat + dat, {{0, 0}, {0, 0}, {0, -1}}], {{1, 1}, {1, 1}, {1, 2}}],
   ArrayPad[ArrayPad[RotateLeft[#] & /@ dat + dat, {{0, 0}, {0, -1}, {0, 0}}], {{1, 1}, {1, 2}, {1, 1}}]}
  ]


(* ::Subsubsection::Closed:: *)
(*Secdiff*)


(*Calculate the second difference of a voxel.*)
SecDiff[dat_] := 
 Module[{H, V, P, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, datR, datL},
  
  With[{
    GammaWrap2 = Compile[{{x, _Integer, 2}}, x - Round[x, 100000]],
    GammaWrap3 = Compile[{{x, _Integer, 3}}, x - Round[x, 100000]]
    },
   datR = RotateRight[dat];
   datL = RotateLeft[dat];
   Switch[ArrayDepth[dat]
   	,
    2(*2D data*),
    H = GammaWrap2[datL - dat] + GammaWrap2[datR - dat];
    V = GammaWrap2[(RotateLeft[#] & /@ dat) - dat] + GammaWrap2[(RotateRight[#] & /@ dat) - dat];
    
    D1 = GammaWrap2[RotateLeft[#] & /@ datL - dat] + GammaWrap2[RotateRight[#] & /@ datR - dat];
    D2 = GammaWrap2[RotateRight[#] & /@ datL - dat] + GammaWrap2[RotateLeft[#] & /@ datR - dat];
    
    ArrayPad[H^2 + V^2 + D1^2 + D2^2, -1]
    ,
    3(*3D data*)    ,
    H = GammaWrap3[((RotateLeft[#] & /@ #) & /@ dat) - dat] + GammaWrap3[((RotateRight[#] & /@ #) & /@ dat) - dat];
    V = GammaWrap3[(RotateLeft[#] & /@ dat) - dat] + GammaWrap3[(RotateRight[#] & /@ dat) - dat];
    P = GammaWrap3[datL - dat] + GammaWrap3[datR - dat];
    
    D1 = GammaWrap3[((RotateLeft[#] & /@ RotateLeft[#]) & /@ dat) - dat] + GammaWrap3[((RotateRight[#] & /@ RotateRight[#]) & /@ dat) - dat];
    D2 = GammaWrap3[((RotateLeft[#] & /@ RotateRight[#]) & /@ dat) - dat] + GammaWrap3[((RotateRight[#] & /@ RotateLeft[#]) & /@ dat) - dat];
    D3 = GammaWrap3[(RotateLeft[#] & /@ datL) - dat] + GammaWrap3[(RotateRight[#] & /@ datR) - dat];
    D4 = GammaWrap3[(RotateLeft[#] & /@ datR) - dat] + GammaWrap3[(RotateRight[#] & /@ datL) - dat];
    D5 = GammaWrap3[(RotateLeft[#] & /@ #) & /@ datL - dat] + GammaWrap3[(RotateRight[#] & /@ #) & /@ datR - dat];
    D6 = GammaWrap3[(RotateLeft[#] & /@ #) & /@ datR - dat] + GammaWrap3[(RotateRight[#] & /@ #) & /@ datL - dat];
    D7 = GammaWrap3[((RotateLeft[#] & /@ RotateLeft[#]) & /@ datL) - dat] + GammaWrap3[((RotateRight[#] & /@ RotateRight[#]) & /@ datR) - dat];
    D8 = GammaWrap3[((RotateRight[#] & /@ RotateLeft[#]) & /@ datL) - dat] + GammaWrap3[((RotateLeft[#] & /@ RotateRight[#]) & /@ datR) - dat];
    D9 = GammaWrap3[((RotateLeft[#] & /@ RotateRight[#]) & /@ datL) - dat] + GammaWrap3[((RotateRight[#] & /@ RotateLeft[#]) & /@ datR) - dat];
    D10 = GammaWrap3[((RotateLeft[#] & /@ RotateLeft[#]) & /@ datR) - dat] + GammaWrap3[((RotateRight[#] & /@ RotateRight[#]) & /@ datL) - dat];
    
    ArrayPad[H^2 + V^2 + P^2 + D1^2 + D2^2 + D3^2 + D4^2 + D5^2 + D6^2 + D7^2 + D8^2 + D9^2 + D10^2, -1]
    ]
   ]
  ]


(* ::Subsection::Closed:: *)
(*Correct Phase*)


CorrectPhase[phase_,left_,right_]:=
Module[{dim,ones,add,out},
	dim=Dimensions[phase];
	ones=ConstantArray[1,{dim[[1]],dim[[2]],dim[[3]]/2}];
	add=Join[left*ones,right*ones,3];
	out=N[phase+add];
	out/.{N[left]->0.,N[right]->0.}
	]


(* ::Subsection:: *)
(*Correct*)


(* ::Subsubsection::Closed:: *)
(*Correct*)


SyntaxInformation[Correct] = {"ArgumentsPattern" -> {_, _, _, _.}};

Correct[data_?MatrixQ,phase_?MatrixQ,shift_]:=
Correcti[data,phase,shift,1]

Correct[data_?MatrixQ,phase_?MatrixQ,shift_,int_]:=
Correcti[data,phase,shift,int]

Correct[data:{_?MatrixQ..},phase:{_?MatrixQ..},shift_]:=
MapThread[Correcti[#1,#2,shift,1]&,{data,phase}]

Correct[data:{_?MatrixQ..},phase:{_?MatrixQ..},shift_,int_]:=
MapThread[Correcti[#1,#2,shift,int]&,{data,phase}]

Correct[data:{{_?MatrixQ..}..},phase:{_?MatrixQ..},shift_]:=
Transpose[Map[MapThread[Correcti[#1,#2,shift,1]&,{#,phase}]&,Transpose[data,{2,1}]],{2,1}]

Correct[data:{{_?MatrixQ..}..},phase:{_?MatrixQ..},shift_,int_]:=
Transpose[Map[MapThread[Correcti[#1,#2,shift,int]&,{#,phase}]&,Transpose[data,{2,1}]],{2,1}]


(* ::Subsubsection::Closed:: *)
(*Correcti*)


Correcti[dat_,ph_,shift_,int_]:=
Module[{pos,acpos,shiftpx,data,phase,output},
	If[shift[[2]]=="COL",
		data=Transpose[dat];phase=Transpose[ph];,
		data=dat;phase=ph;
		];
	shiftpx=phase*shift[[1]];
	output=Round[MapThread[(
		pos=Range[Length[#1]];
		acpos=pos-#1;
		ListInterpolation[#2,InterpolationOrder->int][acpos]
		)&,{shiftpx,data}]];
	If[shift[[2]]=="COL",Return[Transpose[output]],Return[output]]
	]


(* ::Subsection:: *)
(*TensorCorrect*)


(* ::Subsubsection::Closed:: *)
(*TensorCorrect*)


Options[TensorCorrect]={RotationCorrect->False};

SyntaxInformation[TensorCorrect] = {"ArgumentsPattern" -> {_, _, _, _, _., OptionsPattern[]}};

(* zonder masker, dus met sprongen in de afgeleide by grens tussen deformatie veld en achtergrond *)
TensorCorrect[tens_,phase_,shift_,vox_,OptionsPattern[]]:=
TensorCorrect[tens,phase,0,shift,vox];

(* met masker, dus zonder sprongen in de afgeleide by grens tussen deformatie veld en achtergrond *)
TensorCorrect[tens_,phase_,mask_,shift_,vox_,OptionsPattern[]]:=
	Module[{dim,pxshift,der,F,tensM,tensC,tensCV,tensT},
	
	dim=Dimensions[phase];
	(*deformation expessed in pixels*)
	pxshift=phase*shift[[1]];
	
	If[OptionValue[RotationCorrect]==True,
		PrintTemporary["Cacluating Derivative"];
		(*local derivative of the displacement in the slice direction*)
		der=If[!ArrayQ[mask],
		Deriv[pxshift,vox],
		Deriv[pxshift,vox,mask]
		];
		F=Fmat[der,shift[[2]]];
		
		PrintTemporary["Rotation Correction"];
		(*rotation correction of matrix*)
		(*tensor to matrixform*)
		tensM=TensMat[tens];
		(*rotation correct tensor matrix*)
		tensC=MapThread[DRot[#1,#2]&,{tensM,F},3];
		(*corrected tensor back to vector form*)
		tensCV=TensVec[tensC];
		,
		tensCV=tens;
		];
	
	PrintTemporary["Translation Correction"];
	(*Translation correction of the rotation corrected Tensor*)
	tensT=Map[(
		MapThread[
			TransCorrect[#1,#2,shift[[2]],1]
			&,{#,pxshift}
			]
		)&,tensCV]
	];


(* ::Subsubsection::Closed:: *)
(*TransCorrect*)


(* Translation correct one slice*)
TransCorrect[dat_,sh_,dir_,int_]:=
Module[{data,shift,pos,acpos,out},
	(*Transpose the data zo the deformation is always in the "ROW" direction*)
	If[dir=="COL",
		data=Transpose[dat];shift=Transpose[sh];,
		data=dat;shift=sh;
		];
	(*{dims,dimx,dimy}=Dimensions[data];*)
	(*deformation Correction*)
	out=MapThread[(
		pos=Range[Length[#1]];
		acpos=pos-#1;
		ListInterpolation[#2,InterpolationOrder->int][Clip[acpos,{1,Length[acpos]}]]
		(*[{Clip[acpos[[1]],{1,dimx}],Clip[acpos[[2]],{1,dimy}]}]*)
		)&,{shift,data}];
	
	(*If deformation was in the "COL" direction rotate back*)
	If[dir=="COL",Return[Transpose[Chop[out]]],Return[Chop[out]]]
	];


(* ::Subsubsection::Closed:: *)
(*FMat*)


Fmat[der_,shift_]:=
Module[{Dx,Dy,Dz,dim,zero,ones,F},
	{Dx,Dy,Dz}=der;
	dim=Dimensions[Dx];
	zero=ConstantArray[0,dim];
	ones=ConstantArray[1,dim];
	If[shift=="COL",
		F=Transpose[{{ones,zero,zero},{Dx,Dy+1,Dz},{zero,zero,ones}},{4,5,1,2,3}],
		If[shift=="ROW",
			F=Transpose[{{Dx+1,Dy,Dz},{zero,ones,zero},{zero,zero,ones}},{4,5,1,2,3}]
			],
		Print["error, unknown direction"]
		]
	];


(* ::Subsubsection::Closed:: *)
(*Drot*)


DRot[D_,F_]:=Module[{val,e1,e2,e3,n1,n2,n3,NN},
{val,{e1,e2,e3}}=Eigensystem[D];
n1=Normalize[F.e1];
n2=Normalize[F.e2-(n1.(F.e2))*n1]//N;
n3=Normalize[Cross[n1,n2]]//N;
NN=Transpose[{n1,n2,n3}];
Chop[NN.(IdentityMatrix[3]val).Transpose[NN]]
];


(* ::Subsection:: *)
(*Deriv*)


(* ::Subsubsection::Closed:: *)
(*Deriv*)


SyntaxInformation[Deriv] = {"ArgumentsPattern" -> {_, _, _}};

Deriv[disp_,vox_]:=
Module[{dim,Dx,Dy,Dz},
	dim=Dimensions[disp];
	Dx=Transpose[DerivFunc[Transpose[disp,{1,3,2}],dim[[2]],vox[[2]]],{1,3,2}];
	Dy=DerivFunc[disp,dim[[3]],vox[[3]]];
	Dz=Transpose[DerivFunc[Transpose[disp,{3,2,1}],dim[[1]],vox[[1]]],{3,2,1}];
	{Dx,Dy,Dz}
	];

Deriv[disp_,vox_,mask_]:=
Module[{dim,Dx,Dy,Dz},
	dim=Dimensions[disp];
	Dx=Transpose[DerivFunc[Transpose[disp,{1,3,2}],Transpose[mask,{1,3,2}],dim[[2]],vox[[2]]],{1,3,2}];
	Dy=DerivFunc[disp,mask,dim[[3]],vox[[3]]];
	Dz=Transpose[DerivFunc[Transpose[disp,{3,2,1}],Transpose[mask,{3,2,1}],dim[[1]],vox[[1]]],{3,2,1}];
	{Dx,Dy,Dz}
	];


(* ::Subsubsection::Closed:: *)
(*DerivFunc*)


DerivFunc[disp_,length_,step_]:=
Module[{coor,f},
	coor=Range[length]*step;
	Map[(
		f=Interpolation[Transpose[{coor,#}],InterpolationOrder->1];
		Table[f'[st],{st,coor}]
		)&,disp,{2}]
	];

DerivFunc[disp_,mask_,length_,step_]:=
Module[{coor,f,fr,df,dfr},
	coor=Range[length]*step;
	MapThread[(
		f=Interpolation[Transpose[{coor,#1}],InterpolationOrder->1];
		fr=Interpolation[Transpose[{coor,Reverse[#1]}],InterpolationOrder->1];
		df=RotateRight[#2,1]*#2*Table[f'[st],{st,coor}];
		dfr=RotateLeft[#2,1]*#2*-Reverse[Table[fr'[st],{st,coor}]];
		MapThread[If[#1==0,#2,#1]&,{df,dfr}]
		)&,{disp,mask},2]
	];


(* ::Subsection:: *)
(*Join sets*)


(* ::Subsubsection::Closed:: *)
(*JoinSets*)


Options[JoinSets]={ReverseSets->True,ReverseData->True};

SyntaxInformation[JoinSets] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

JoinSets[dat_?ArrayQ,overlap_?IntegerQ,OptionsPattern[]]:=
Module[{data,sets,set1,set2,step,set1over,set2over,joined},
	
	(*reverse the order of the slices and the sets*)
	data=If[OptionValue[ReverseData],Reverse[dat,2],dat];
	data=If[OptionValue[ReverseSets],Reverse[data],data];
	
	sets=Length[data];
	step=1/(overlap+1);
	
	(*perform the join*)
	For[i=1,i<sets,i++,
		If[i==1,
			set1=Drop[data[[i]],{-overlap,-1}];
			set1over=Take[data[[i]],{-overlap,-1}];,
			set1=Drop[joined,{-overlap,-1}];
			set1over=Take[joined,{-overlap,-1}];
			];
		set2=Drop[data[[i+1]],{1,overlap}];
		set2over=Take[data[[i+1]],{1,overlap}];
		(*joined=Joini[{set1,set2},{set1over,set2over},step];*)
		joined = Joini[{set1, set2}, {set1over, set2over}, overlap];
		];
		
	(*give output*)	
	Return[If[OptionValue[ReverseData],Reverse[joined],joined]]
	];

JoinSets[dat_?ArrayQ,overlap_?ListQ,OptionsPattern[]]:=
Module[{data,sets,set1,set2,i,step,set1over,set2over,joined,overSet,data1,data2,drop1,drop2,overl},
	
	(*reverse the order of the slices and the sets*)
	data=If[OptionValue[ReverseData],Reverse[dat,2],dat];
	data=If[OptionValue[ReverseSets],Reverse[data],data];
	
	sets=Length[data];
	
	(*perform the join*)
	For[i=1,i<sets,i++,
		overSet=overlap[[i]];
		If[i==1,
			data1=data[[i]];,
			data1=joined;
			];
		If[Length[overSet]!=3&&!IntegerQ[overSet],
			Return[Message[JoinSets::over,overSet]];
			,
			If[IntegerQ[overSet],
				step=1/(overSet+1);
				data2=data[[i+1]];
				overl=overSet;
				,
				If[Length[overSet]==3,
					overl=overSet[[1]];
					step=1/(overl+1);
					drop1=overSet[[2]];
					drop2=overSet[[3]];
					If[drop1!=0,data1=Drop[data1,{-drop1,-1}]];
					If[drop2!=0,data2=Drop[data[[i+1]],{1,drop2}];,data2=data[[i+1]];];
					]
				]
			];
		set1=Drop[data1,{-overl,-1}];
		set1over=Take[data1,{-overl,-1}];
		set2=Drop[data2,{1,overl}];
		set2over=Take[data2,{1,overl}];
		(*joined=Joini2[{set1,set2},{set1over,set2over},step];*)
		joined=Joini[{set1,set2},{set1over,set2over},overl];
		];
		
	(*give output*)
	Return[If[OptionValue[ReverseData],Reverse[joined],joined]]
	];


(* ::Subsubsection::Closed:: *)
(*Joini*)


Joini[sets_, setover_, step_] := 
 Module[{over,dat,unit,noZero,tot,datU},
 	unit=Unitize[setover];
 	noZero=Times@@unit;
 	tot=Total[noZero];
 	noZero=Transpose[noZero,{3,1,2}];
 	dat=Transpose[setover, {3,4,1,2}];
 	datU=Transpose[unit,{3,4,1,2}];
 	over = Transpose[JoinFuncC[dat, datU, noZero, tot, step], {2, 3, 1}];
 	
  (*over = Transpose[
    MapThread[
    	(JoinFunc[#1,#2,#3,#4,step])&,{dat,datU,noZero,tot}
     , 2], {2, 3, 1}];*)
     Join[sets[[1]], over, sets[[2]]]
  ]

JoinFuncC = Block[{ran, posit, unit, tot1, out},
   Compile[{
     {dat, _Real, 2}, {datU, _Real, 2}, {noZero, _Integer, 1},
     {tot, _Integer, 0}, {steps, _Integer, 0}
     },
    If[tot === 0,
     out = ConstantArray[0., {steps}]
     ,
     tot1 = 1./(tot + 1.);
     ran = Range[tot1, 1. - tot1, tot1];
     If[tot === steps,
      unit = {1. - ran, ran} ;
      ,
      unit = datU;
      unit[[All, Flatten[Position[noZero, 1]]]] = {(1. - ran), ran};
      ];
     out = Total[unit dat];
     ];
    out
    , {{out, _Real, 1}}, RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]
   ];

JoinFunc[dat_,datU_,noZero_,tot_, steps_] := 
 Module[{ran, posit, unit,tot1},
  unit = datU;
  Switch[tot,
    0,
    ConstantArray[0, {steps}],
    steps,
    tot1= 1./(tot+1);
    ran = Range[tot1, 1-tot1, tot1];
    Total[{1 - ran, ran} dat],
    _,
    posit = Flatten[Position[noZero, 1]];
    tot1= 1./(tot+1);
    ran = Range[tot1, 1-tot1, tot1];
    (unit[[All, posit]] = {(1 - ran),ran});
    Total[unit dat]
    ]
  ]



(* ::Subsection::Closed:: *)
(*TensMat*)


SyntaxInformation[TensMat] = {"ArgumentsPattern" -> {_}};

TensMat[tens:{_?ArrayQ..}]:=
Transpose[{{tens[[1]],tens[[4]],tens[[5]]},{tens[[4]],tens[[2]],tens[[6]]},{tens[[5]],tens[[6]],tens[[3]]}},{4,5,1,2,3}];

TensMat[tens_?ListQ]:=
	{{tens[[1]],tens[[4]],tens[[5]]},{tens[[4]],tens[[2]],tens[[6]]},{tens[[5]],tens[[6]],tens[[3]]}};


(* ::Subsection::Closed:: *)
(*TensVec*)


SyntaxInformation[TensVec] = {"ArgumentsPattern" -> {_}};

TensVec[tens:{{_,_,_},{_,_,_},{_,_,_}}]:=
	{tens[[1,1]],tens[[2,2]],tens[[3,3]],tens[[1,2]],tens[[1,3]],tens[[2,3]]};

TensVec[tens:{_?ArrayQ..}]:=
Transpose[Map[{#[[1,1]],#[[2,2]],#[[3,3]],#[[1,2]],#[[1,3]],#[[2,3]]}&,tens,{3}],{2,3,4,1}];


(* ::Subsection::Closed:: *)
(*Data2DToVector*)


SyntaxInformation[Data2DToVector] = {"ArgumentsPattern" -> {_, _.}};

Data2DToVector[datai_]:=Data2DToVector[datai,1]
Data2DToVector[datai_,maski_]:=Block[{data,depth,mask,pos,vecdata,dimd,dimm},

depth=ArrayDepth[datai];
If[!(depth==2||depth==3),Return@Message[Data2DToVector::dim,depth]];
dimd=If[depth==2,Dimensions[datai],Drop[Dimensions[datai],1]];
dimm=Dimensions[maski];

If[!(mask===1)&&dimm!=dimd,Return@Message[Data3DToVector::mask,dimd,dimm]];

data=N@If[depth==3,maski #&/@datai,maski datai];
mask=Unitize@If[depth==3,Total[data],data];
pos=Position[mask,1];

vecdata=If[depth==3,
DeleteCases[Flatten[TransData[data,"l"],1],ConstantArray[0.,Length[datai]]],
DeleteCases[Flatten[data],0.]
];

{vecdata,{dimd,pos}}
];


(* ::Subsection::Closed:: *)
(*Data3DToVector*)


SyntaxInformation[Data3DToVector] = {"ArgumentsPattern" -> {_, _.}};

Data3DToVector[datai_]:=Data3DToVector[datai,1]
Data3DToVector[datai_,maski_]:=Module[{data,depth,mask,pos,vecdata,dimd,dimm},

depth=ArrayDepth[datai];
If[!(depth==3||depth==4),Message[Data3DToVector::dim,depth]];
dimd=If[depth==3,Dimensions[datai],Drop[Dimensions[datai],1]];
dimm=Dimensions[maski];

If[!(mask===1)&&dimm!=dimd,Return@Message[Data3DToVector::mask,dimd,dimm]];

data=N@If[depth==4,maski #&/@datai,maski datai];
mask=Unitize@If[depth==4,Total[data],data];
pos=Position[mask,1];

vecdata=If[depth==4,
DeleteCases[Flatten[TransData[data,"l"],2],ConstantArray[0.,Length[datai]]],
DeleteCases[Flatten[data],0.]
];

{vecdata,{dimd,pos}}
];


(* ::Subsection::Closed:: *)
(*TransData*)


SyntaxInformation[TransData] = {"ArgumentsPattern" -> {_, _}};

(*
TransData[data_,dir_]:=Block[{ran,dep},
ran=Range[dep=ArrayDepth[data]];
Switch[dir,
"r",Transpose[data,RotateLeft[ran]],
"l",Transpose[data,RotateRight[ran]]
]
]

*)

TransData[data_,dir_]:=Block[{ran,dep,fun},
ran=Range[dep=ArrayDepth[data]];
fun=Switch[dir,"r",RotateLeft[ran],"l",RotateRight[ran]];
Transpose[data,fun]
]



(* ::Subsection::Closed:: *)
(*VectorToData*)


SyntaxInformation[VectorToData] = {"ArgumentsPattern" -> {_, {_, _}}};

VectorToData[vec_,{dim_, pos_}]:=Block[{output,len},
len=Length@First@vec;
output=Switch[len,
0,ConstantArray[0.,dim],
_,ConstantArray[ConstantArray[0.,len],dim]
];
Switch[
Length[dim],
2,MapThread[(output[[#2[[1]],#2[[2]]]]=#1)&,{vec,pos}],
3,MapThread[(output[[#2[[1]],#2[[2]],#2[[3]]]]=#1)&,{vec,pos}]
];
Switch[len,0,output,_,TransData[output,"r"]]
]


(* ::Subsection::Closed:: *)
(*DriftCorrect*)


Options[DriftCorrect]={NormalizeSignal->True,UseMask->True}

SyntaxInformation[DriftCorrect] = {"ArgumentsPattern" -> {_, _,_., OptionsPattern[]}}

DriftCorrect[data_, bi_, opts:OptionsPattern[]] := 
 Block[{bval,pos},

  bval = If[ArrayDepth[bi] == 2, BmatrixInv[bi][[1]], bi];
  
  pos = First@UniqueBvalPosition[bval, 6][[2]];

	DriftCorrect[data, bval, pos, opts]

  ];
  
DriftCorrect[data_, bi_,pos_, OptionsPattern[]] := 
 Block[{sig, cor, bval, sol1, sol2, sol3, a, b, c, x,outp},
  bval = If[ArrayDepth[bi] == 2, BmatrixInv[bi][[1]], bi];
  
  sig = MeanSignal[data, pos,UseMask->OptionValue[UseMask]];
  
  {sol1, sol2, sol3} = {a, b, c} /. FindFit[Transpose[{pos, sig}], {c + b x + a x^2}, {a, b, c}, x];
  cor = sol3/Table[sol3 + sol2 x + sol1 x^2, {x, 1, Length[bi]}];
  
  outp = ConstantArray[cor, Length[data]] data;
  
  If[OptionValue[NormalizeSignal], 100 outp / (sig[[1]] cor[[1]]) , outp ]
  ];


(* ::Subsection::Closed:: *)
(*CutData*)


SyntaxInformation[CutData] = {"ArgumentsPattern" -> {_,_.}}

CutData[data_]:=CutData[data,FindMiddle[data]]

CutData[data_,cut_] := Switch[
		ArrayDepth[data],
		4,{data[[All, All, All, ;; cut]],data[[All, All, All, (cut + 1) ;;]],cut},
		3,{data[[All, All, ;; cut]], data[[All, All, (cut + 1) ;;]],cut}
]

FindMiddle[dati_] := Module[{dat, len, r1, r2, sec1},
  dat = N@Nest[Mean, dati, ArrayDepth[dati] - 1];
  len = Length[dat];
  {r1, r2} = len/2 + {-20, 20};
  sec1 = Transpose[{dat, Range[len]}][[r1 ;; r2]];
  Last[First[Sort[sec1]]]
  ]

(* ::Subsection::Closed:: *)
(*StichData*)


SyntaxInformation[StichData] = {"ArgumentsPattern" -> {_,_}}

StichData[datal_, datar_] := TransData[Join[TransData[datal, "r"], TransData[datar, "r"]], "l"];


(* ::Subsection:: *)
(*TransformData*)


(* ::Subsubsection::Closed:: *)
(*TransformData*)


Options[DataTranformation]={InterpolationOrder->1}

SyntaxInformation[DataTranformation]={"ArgumentsPattern"->{_,_,_,OptionsPattern[]}};

DataTranformation[data_, vox_, wi_,OptionsPattern[]] := 
 Block[{coor, rot, coorR, interFunc, interFuncC},
  w=If[Length[wi]==3,Join[wi,{0,0,0,1,1,1,0,0,0}]];
  
  coor = GetCoordinates[data, vox];
  rot = ParametersToTransformFull[w, "Inverse"];
  coorR = ApplyRotC[coor, rot];
  interFunc = 
   Interpolation[
    Transpose[{Flatten[coor, ArrayDepth[coor] - 2], Flatten[data]}], 
    InterpolationOrder -> OptionValue[InterpolationOrder], 
    "ExtrapolationHandler" -> {0. &, "WarningMessage" -> False}];
  interFuncC = 
   Compile[{{coor, _Real, 1}}, 
    interFunc[coor[[1]], coor[[2]], coor[[3]]], 
    RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];
  interFuncC[coorR]
  ]


(* ::Subsubsection::Closed:: *)
(*GetCoordinates*)


GetCoordinates[data_, vox_] := Block[{dim, off, coor},
   off = Dimensions[data]/2;
   coor = MapIndexed[#2 &, data, {ArrayDepth[data]}] - 0.5;
   CoordC[coor, off, vox]
   ];


(* ::Subsubsection::Closed:: *)
(*CoordC*)

   
CoordC = Compile[{{coor, _Real, 1}, {off, _Real, 1}, {vox, _Real, 1}},
    vox (coor - off),
   RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*ApplyRotC*)


ApplyRotC = Compile[{{coor, _Real, 1}, {rot, _Real, 2}}, 
  	(rot.Append[coor, 1])[[1 ;; 3]],
   RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*ParametersToTransformFull*)


ParametersToTransformFull[w_] := ParametersToTransformFull[w, "Normal"]

ParametersToTransformFull[w_, opt_] := Block[{
	tx, ty, tz, rx, ry, rz, sx, sy, sz, gx, gy, gz, 
	T, R, G, S, Rx, Ry, Rz, Gx, Gy, Gz, 
	mat, rMat, tMat}, 
	
	{rx, ry, rz, tx, ty, tz, sx, sy, sz, gx, gy, gz} = w;
	rx = -rx Degree; ry = -ry Degree; rz = -rz Degree;
	T = {{1, 0, 0, tx}, {0, 1, 0, ty}, {0, 0, 1, tz}, {0, 0, 0, 1}};
	
	Rx = {{1, 0, 0, 0}, {0, Cos[rx], Sin[rx], 0}, {0, -Sin[rx], Cos[rx], 0}, {0, 0, 0, 1}};
	Ry = {{Cos[ry], 0, -Sin[ry], 0}, {0, 1, 0, 0}, {Sin[ry], 0, Cos[ry], 0}, {0, 0, 0, 1}};
	Rz = {{Cos[rz], Sin[rz], 0, 0}, {-Sin[rz], Cos[rz], 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
	R = Rx.Ry.Rz;
	
	Gx = {{1, 0, gx, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
	Gy = {{1, 0, 0, 0}, {gy, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
	Gz = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, gz, 1, 0}, {0, 0, 0, 1}};
	G = Gx.Gy.Gz;
	
	S = {{sx, 0, 0, 0}, {0, sy, 0, 0}, {0, 0, sz, 0}, {0, 0, 0, 1}};
	
	mat = T.R.G.S;
	
	Switch[opt,
		"Normal",
		mat,
		"Inverse",
		rMat = Inverse[mat[[1 ;; 3, 1 ;; 3]]];
		tMat = -rMat.mat[[1 ;; 3, 4]];
		Append[Flatten /@ Thread[{rMat, tMat}], {0, 0, 0, 1}]
		]
	]


(* ::Subsubsection::Closed:: *)
(*ParametersToTransformFull*)


InvertDataset[data_] := Module[{dep},
  dep = ArrayDepth[data];
  Switch[dep,
   4, Transpose[Inverse3Di /@ Transpose[data]],
   _, Inverse3Di[data]
   ]
  ]

Inverse3Di[data_] := Block[{out},
  out = data;
  (out = Reverse[out, #]) & /@ {1, 2};
  out]



(* ::Section:: *)
(*End Package*)


End[]

If[DTITools`verbose,Print[Names["DTITools`ManipulationTools`*"]]];
SetAttributes[#,{Protected, ReadProtected}]&/@ Names["DTITools`ManipulationTools`*"];

EndPackage[]
