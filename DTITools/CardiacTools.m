(* ::Package:: *)

(* ::Title:: *)
(*DTITools CardiacTools*)

(*test*)
(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["DTITools`CardiacTools`",{"Developer`"}];
$ContextPath=Union[$ContextPath,System`$DTIToolsContextPaths];

Unprotect @@ Names["DTITools`CardiacTools`*"];
ClearAll @@ Names["DTITools`CardiacTools`*"];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection:: *)
(*Functions*)

CalculateWallMap::usage = 
"CalculateWallMap[mask,vox] Calculates the wall distance map and the wall derivative, output is {wallmap, der}."

HelixAngleCalc::usage = 
"HelixAngleCalc[eigenvectors, mask, centerpoint, vec, inout, vox]  calculates the helix angle matrix of cardiac data using only a left ventricle mask.
HelixAngleCalc[eigenvectors, mask, maskp, centerpoint, vec, inout, vox] calculates the helix angle matrix of cardiac data using a left vantricle mask and a mas for visualization.

eigenvectors are the tensor eigenvectors calculated with EigenvecCalc.
mask is a mask of the left ventricle.
maskp is a mask used for visualization.
off is the center of each slice calculated with CentralAxes.
inout is the inner and outer radius calcualted with CentralAxes.
vec is the vector describin the central axes of the heart, calculated with CentralAxes.
vox is the voxels size, {slice, x, y}.

output is het fiber angle matrix FAM = {9, slice, x, y} or {FAM, plot}."

CentralAxes::usage = 
"CentralAxes[mask, vox] calculates the center of the lumen from a mask of the left ventricle. vox is the voxels size, {slice, x, y}.
CentralAxes[mask, maskp, vox] allows for fancy visualization of the other structures using maskp.

output is {centerpoints, normalvecs, inout} or {centerpoints, normalvecs, inout, fit}."

CardiacSegment::usage = 
"CardiacSegment[data, mask, off] allows to segment the heart in 1, 4, 6 or AHA-17 segements for each slice 360 radial samples are generated.

data is a background image. 
mask is the mask of the left ventricle (same as used for CentralAxes).
off is the centerpoints generated by CentralAxes.

output is {segmask, segang, {points, slices}}."

RadialSample::usage = 
"RadialSample[mask, data, segang] radialy samples the provided data. 

The mask should be a mask of the left ventricle that was used in the CardiacSegment.
segang is the output of the cardaic SegmentFunction.

output is {points, vals} which are orderd as indicated by the user."

MaskHelix::usage = 
"MaskHelix[helix, mask] masks helix angle data, sets the background to -100 and allows for Median filter of the helix mask.
helix can be a singel map or the FAM."

BullseyePlot::usage = 
"BullseyePlot[data, segmask] generates a AHA-17 segement bullseye plot. 

data is a 3D volume used for the plot. 
segmask is the AHA-17 segmentation resulting form the CardiacSegment function when AHA17 is selected.
BullseyePlot[list] generates a AHA-17 segement bullseye plot of the list (17 values) provide.

output is a bullseye plot or a plotwindow."

PlotSegments::usage = 
"PlotSegments[mask, data, segang] shows how the heart wil be sampled by RadialSample. 

The mask should be a mask of the left ventricle that was used in the CardiacSegment.
function and the segang is the output of the cardaic SegmentFunction.

output is a plot window"

PlotSegmentMask::usage = 
"PlotSegmentMask[mask, segmask, vox] plots the mask segements created by CardiacSegment.

The mask should be a mask of the left ventricle that was used in the CardiacSegment.
segmask is the output of CardiacSegemnt.
vox is the voxels size, {slice, x, y}.

output is a plot window."

TransmuralPlot::usage = "TransmuralPlot[data] plots transmural profiles of the data.
data can be a single profile or a list of profiles. In the second case the mean and standardeviations are plotted."

(*
CreateHeart::usage="CreateHeart[]"
*)

(* ::Subsection:: *)
(*Options*)


ShowPlot::usage = 
"ShowPlot is an option for HelixAngleCalc. If true the it also outputs a visulization of the local myocardial coordinate system."

HelixMethod::usage = 
"HelixMethod is an option for HelixAngleCalc. Can be \"Slow\" or \"Fast\". 
\"Slow\" uses wall distance interpolation and can take long for high res datasets.
\"Fast\" uses wall distance calculation using circular approximation of the ventricle."

RowSize::usage =
"RowSize is an option for CentralAxes. defines the number or images per showing the segmentation.
Can be \"Automatic\" of an integer." 

ShowFit::usage = 
"ShowFit is an option for CentralAxes. True shows the fit of the central axes."

StartPoints::usage = 
"StartPoints is an option for CardiacSegment. Value is \"Default\" or the point list given by CardiacSegment."

StartSlices::usage = 
"StartSlices is an option for CardiacSegment. Value is \"Default\" or the list given by CardiacSegment."

LineThreshold::usage = 
"LineThreshold is an option for CardiacSegment. Can be number between 0 and 1. Increasing the value will decrease the amount of wall sampled."

LineStep::usage = 
"LineStep is an option for CardiacSegment."

SmoothHelix::usage = 
"SmoothHelix is an option for MaskHelix, sets the kernelsize for the MedianFilter." 

BackgroundValue::usage = 
"BackgroundValue is an option for MaskHelix. Sets the backgroud value."

TextOffset::usage = 
"TextOffset is an option for BullseyePlot. Determines where the text is placed, can be 0 to 1."

TextSize::usage = 
"TextSize is an option for BullseyePlot. Determines the text size."

BullPlotMethod::usage = 
"BullPlotMethod is an option for BullseyePlot. Can be \"Dynamic\" of \"Normal\". 
\"Dynamic\" allows to change plotting parameters in Manipulation window."

RadialSamples::usage =
"RadialSamples is an option for RadialSample and PlotSegments. Defines how manny transmural samples are taken."

DropSamples::usage = 
"DropSamples is an option for RadialSample and PlotSegments. Defines how manny samples are droped form star and end. Can be an number or set (strat, end) of numbers."

GridLineSpacing::usage = "GridLineSpacing is an option of TransmuralPlot. It defines the spacing of the gridlines.";


(* ::Subsection:: *)
(*Error Messages*)


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


Options[CalculateWallMap] = {ShowFit -> True};

SyntaxInformation[
   CalculateWallMap] = {"ArgumentsPattern" -> {_, _, 
     OptionsPattern[]}};

CalculateWallMap[mask_, vox_, OptionsPattern[]] := Module[{
   seg, min, mout, mtot, pts, ptsi, pos, ptso, x, y, z, plane, maxd, 
   dis,
   surfpl, pointspl, planepl, planefit, i, fit,
   planem, d1, d2, d3, zc, mask2, in, out, min2, mout2, clip,
   surfin, surfout, ptsin, ptsout, ptspl,
   inpnt, outpnt, wall, pt, t1, pt1, pt2, dist1, dist12, dist22, dist2,
   ptsm, dist, der
   },
  
  (*create the inner and outer volume*)
  seg = MorphologicalComponents[#] & /@ (1 - mask);
  seg = If[#[[1, 1]] == 2, # /. {2 -> 1, 1 -> 2}, #] & /@ seg;
  min = Unitize[Clip[seg, {1.5, 2}, {0, 0}]];
  mout = Unitize[1 - Clip[seg, {0, 1}, {0, 0}]];
  mtot = (mout + 1) - 2 min;
  
  (*get the top points to fit top plane*)
  pts = ptsi = Flatten[MapIndexed[(
        pos = Position[#1, 1.] - 1;
        If[pos != {}, Join[Last[pos], #2], Nothing]
        ) &, N@TransData[mask, "l"], {2}], 1];
  ptso = {{0, 0, 0}};
  
  (*fit the top plane*)
  Clear[x, y, z];
  plane = Fit[Reverse /@ pts, {1, x, y}, {x, y}];
  maxd = Max[{(1./(0.5 Norm[vox])), 0.25}];
  While[ptsi != ptso,
   ptsi = ptso;
   ptso = Select[pts, (
       dis = (((plane - z) /. Thread[{x, y, z} -> Reverse[#]]));
       dis < 1.5 maxd || Abs[dis] < maxd
       ) &];
   plane = Fit[Reverse /@ ptso, {1, x, y}, {x, y}];
   ];
  
  (*plane fit visualisation*)
  surfpl = 
   ListContourPlot3D[GaussianFilter[mask, 1], Contours -> {0.6}, 
    Mesh -> False, 
    PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}], 
    BoxRatios -> Reverse@(vox Dimensions[mask]), 
    ContourStyle -> Directive[Gray, Opacity[0.5]], 
    Lighting -> "Neutral", Axes -> False];
  pointspl = 
   ListPointPlot3D[Reverse[# - {0, 1, 1}] & /@ ptsi, 
    PlotRange -> Transpose[{{0, 0, 0}, Reverse@Dimensions[mask]}], 
    BoxRatios -> 1, PlotStyle -> Red];
  planepl = 
   Plot3D[plane,  {x, 0, Dimensions[mask][[3]]}, {y, 0, 
     Dimensions[mask][[2]]}, Mesh -> False, 
    PlotStyle -> Directive[Red, Opacity[.2]], 
    BoundaryStyle -> Darker[Red]];
  planefit = 
   Show[surfpl, planepl, pointspl, PerformanceGoal -> "Speed"];
  
  (*make mask from plan*)
  planem = 0 mout;
  {d1, d2, d3} = Dimensions[planem];
  Table[
   zc = (Round[plane] + o) /. {x -> xc, y -> yc};
   If[zc <= d1 && mout[[zc, yc, xc]] != 1, 
    planem[[zc, yc, xc]] = 1], {xc, 1, d3}, {yc, 1, d2}, {o, 2, 5}];
  
  (*close gap between mask and top plane*)
  mask2 = mask;
  in = mask2; out = 0 mask2;
  i = 0;
  While[in != out && i < 20,
   i++;
   in = mask2;
   out = (1 - 
       min) (ArrayPad[
        Closing[ArrayPad[mask2 + planem, 20], 0.5], -20] - planem);
   mask2 = out;
   ];
  
  (*fill inner mask up to plane*)
  min2 = min;
  in = min2; out = 0 min2;
  clip = Clip[(1 - mask2 - planem), {0, 1}];
  i = 0;
  While[in != out && i < 20,
   i++;
   in = min2;
   out = clip ArrayPad[Dilation[ArrayPad[min2, 20], 0.5], -20];
   min2 = out;
   ];
  mout2 = ArrayPad[Closing[ArrayPad[mask + min2, 5], 1], -5];
  {min2, mout2};
  
  (*Create Inner and outer surfaces*)
  {surfout, surfin} = 
   ListContourPlot3D[GaussianFilter[min2 + mout2, 1], 
      Contours -> {0.3, 1.5}[[#]], Mesh -> False,
      PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}],
      Lighting -> "Neutral", 
      BoxRatios -> Reverse@(vox Dimensions[mask]),
      ContourStyle -> Directive[{Red, Blue}[[#]], Opacity[0.4]], 
      MaxPlotPoints -> {50, 100}] & /@ {1, 2};
  
  Print[surfout,surfin];
  
  (*get the coordinates from the inner and outer surface*)
  ptsin = 
   Reverse /@ Cases[surfin, GraphicsComplex[x_, ___] :> x][[1]] + 1;
  ptsout = 
   Reverse /@ Cases[surfout, GraphicsComplex[x_, ___] :> x][[1]] + 1;
  
  ptspl = 
   Show[surfin, surfout, 
    ListPointPlot3D[{Reverse /@ ptsin - 1, Reverse /@ ptsout - 1}, 
     PlotStyle -> {Blue, Red}], PerformanceGoal -> "Speed"];
  
  inpnt = N[vox # & /@ ptsin]; outpnt = N[vox # & /@ ptsout];
  (*generate the wall distance function*)
  wall = 0 mask + 1;
  ptsm = N@Position[mask, 1];
  DistributeDefinitions[inpnt,outpnt];
  dist = ParallelMap[(
      pt = vox #;
      t1 = AbsoluteTiming[
        pt1 = Mean[Nearest[inpnt, pt, 3]];
        pt2 = Mean[Nearest[outpnt, pt, 3]];
        ];
      dist1 = Chop[Norm[pt1 - pt2]];
      dist12 = Chop[Norm[pt1 - pt]];
      dist22 = Chop[Norm[pt2 - pt]];
      dist2 = 
       If[dist1 == 0., 0., Mean[{dist12/dist1, 1 - (dist22/dist1)}]];
      (*{pt1,pt,pt2,dist1,*)dist2
      ) &, ptsm];
  (*create the wall distance map*)
  MapThread[(wall[[#1[[1]], #1[[2]], #1[[3]]]] = #2) &, {ptsm, dist}];
  wall = MedianFilter[wall*(1 - min2), 1];
  der = GaussianFilter[
      wall, {1.5 (1/vox)/(1/vox[[1]])}, #] & /@ (IdentityMatrix[3]); 
  
  wall = mask wall;
  wall = NormalizeData[wall, MinMax[wall]];
  der = mask # & /@ der;
  
  If[OptionValue[ShowFit], 
   fit = Print[GraphicsRow[{planefit, ptspl}, ImageSize -> 800]]];
  If[OptionValue[ShowFit], {wall, der, fit}, {wall, der}]
  ]


(* ::Subsection:: *)
(*HelixAngleCalc*)


(* ::Subsubsection::Closed:: *)
(*HelixAngleCalc*)


Options[HelixAngleCalc]={ShowPlot->True, HelixMethod->"Slow"};

SyntaxInformation[HelixAngleCalc]={"ArgumentsPattern"->{_,_,_,_.,OptionsPattern[]}};

HelixAngleCalc[data_?ArrayQ,mask_?ArrayQ,off_,vec_,inout_,vox_,opts:OptionsPattern[]]:=HelixAngleCalc[data,mask,0,off,vec,inout,vox,opts]

HelixAngleCalc[data_?ArrayQ,mask_?ArrayQ, maskp_?ArrayQ,off_,vec_,inout_,vox_,OptionsPattern[]]:=Module[
{norvec,radvec,radvecn,cirvec,projection,helix,sign,
evec,inp,dim,wallangmap,norvecc,mtot,func2,
vectorField,vectorFieldE,n,coo,plot,out,voxl,cent,offp,
rav,nov,rov,spz,spxy,sp,
seg,min,mout,intdata,func,wall,der,
maskCont,vec1,vec2,vec3},


dim=Dimensions[data][[1;;3]];
voxl=Reverse[vox];

Switch[OptionValue[HelixMethod]
	,
	"Fast"
	,
	Print["start"];
	(*calculate the wall angle map*)
	wallangmap=N[WallAngleMap[mask,vox,inout]Degree];
	(*define te rad vector using center points*)
	radvec=RadVecC[dim,off];
	(*define norvecs using centerline vectors*)
	norvec=ConstantArray[vec[[#]],dim[[2;;]]]&/@Range[dim[[1]]];
	(*define rotation vectors perpendicualr to radvecn and norvec*)
	cirvec=NormalizeC[CrossC[radvec,norvec]];
	(*correct the norvec for the wall curvature by rotation around rotvec*)
	norvecc=NorVecR[wallangmap,cirvec,norvec];
	(*make radvec purpendicular to corrected norvec*)
	radvecn=MakePerpendicular[radvec,norvecc];
	Print["end"]
	,
	"Slow"
	,
	seg = MorphologicalComponents[#] & /@ (1 - mask);
	min = Round@GaussianFilter[Unitize[Clip[seg, {1.5, 2}, {0, 0}]], 3];
	mout = Round@GaussianFilter[Unitize[1 - Clip[seg, {0, 1}, {0, 0}]], 3];
	mtot = (Dilation[mout, 1] + 1) - 2 min;
	intdata = N@Join[Append[vox #, 0.] & /@ Position[min, 1], Append[vox #, 1.] & /@ Position[1 - Dilation[mout, 1], 1]];
	func = Interpolation[intdata, InterpolationOrder -> 1];
	func2 = If[(mtot[[##]] & @@ #) != 2, (mtot[[##]] & @@ #), func @@ (vox #)] &;
	
	(*idat = Transpose[Table[vox {z, y, x}, {z, 1, dim[[1]]}, {y, 1, dim[[2]]}, {x, 1,dim[[3]]}], {2, 3, 4, 1}];
	wall = GaussianFilter[func[##] & @@ idat, 2];*)
	wall = Table[func2[{z, y, x}], {z, 1,dim[[1]]}, {y, 1, dim[[2]]}, {x, 1,dim[[3]]}];
	
	der = GaussianFilter[wall, {1.5 (1/vox)/(1/vox[[1]])}, #] & /@ (IdentityMatrix[3]);
	radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
	norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
	norvecc = MakePerpendicular[norvec, radvecn];
	cirvec = NormalizeC[CrossC[radvecn,norvecc]];
	,
	"Slow2"
	,
	{wall,der}=CalculateWallMap[mask,vox,ShowFit->False];
	radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
	norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
	norvecc = MakePerpendicular[norvec, radvecn];
	cirvec = NormalizeC[CrossC[radvecn,norvecc]];

];

(*create helix angle maps*)
out = Flatten[Table[
	evec=Map[Reverse,data[[All,All,All,i]],{3}];
	(*align vector with projection vector*)
	evec=Sign2[DotC[{norvecc,radvecn,cirvec}[[j]],evec]] evec;
	(*evec=Sign2[DotC[{norvecc,radvecn,rotvec}[[j]],evec]] evec;*)
	(*Helix,Transverse,Sheet}*)
	projection = MakePerpendicular[evec, {radvecn,cirvec,norvecc}[[j]]];
	(*projection = MakePerpendicular[evec, {rotvec,norvec,radvecn}[[j]]];*)
	inp = DotC[projection,{cirvec,norvecc,radvecn}[[j]]];
	helix=ArcCos[Abs[inp]]/Degree;
	sign=If[(j==1 && i==1),Sign2[inp],1];
	sign helix
	, {i, 3}, {j, 3}],1];

	sp = Round[Dimensions[mask]/{12, 24, 24}];
	{spz,spxy} = {sp[[1]], Min[sp[[2 ;; 3]]]};

If[OptionValue[ShowPlot],
		(*creat a plot showing the local axes system*)
	maskCont = PlotMaskVolume[mask + maskp, vox];
	n = (spz 0.6 vox[[1]]){1, -1, 1} /vox;
  	vectorField = Table[
  		If[mask[[z, y, x]] == 0,
  			{None, None, None},
  			coo = {x, -y + dim[[2]] + 1, z};
  			rav = Reverse[n radvecn[[z, y, x]]];
  			nov = Reverse[n norvecc[[z, y, x]]];
  			rov = Reverse[n cirvec[[z, y, x]]];
  			{
  				{Darker[Green], Thick, Line[{coo(* - rav*), coo + rav}]},
  				{Darker[Blue], Thick, Line[{coo(* - nov*), coo + nov}]},
  				{Darker[Red], Thick, Line[{coo(* - rov*), coo + rov}]}
     		}
     		], {z, 1, dim[[1]], spz}, {y, 1,dim[[2]], spxy}, {x, 1, dim[[3]], spxy}
     	];
	{vec1, vec2, vec3} = DeleteCases[Flatten[#, 2], None] & /@ Transpose[vectorField, {2, 3, 4, 1}];
	     
	vectorFieldE = DeleteCases[Flatten[Table[
    	If[mask [[z, y, x]] == 0,
       		None,
        	coo = ({x, -y + dim[[2]], z} + {.5, .5, 0});
        	rav = n data[[z,y,x,3]];
        	nov = n data[[z,y,x,1]];
        	rov = n data[[z,y,x,2]];
	        {
	         {Green, Thick, Line[{coo - rav, coo + rav}]}, 
	         {Blue, Thick, Line[{coo - nov, coo + nov}]},
	         {Red, Thick, Line[{coo - rov, coo + rov}]}
	         }
	         ]
	     , {z, 1, dim[[1]],1}, {y, 1, dim[[2]], 3}, {x, 1, dim[[3]], 2}],3], None];
	     
	offp = {.5, .5+dim[[2]], 0} + {1, -1, 1} Reverse[#] & /@ DeleteCases[off, {}];
	cent=Show[ListPointPlot3D[offp,PlotStyle -> Directive[{Thick, Black, PointSize[Large]}]],Graphics3D[{Thick, Black, Line[offp]}]];
  	plot = Show[maskCont, Graphics3D[vec1], Graphics3D[vec2], Graphics3D[vec3](*,Graphics3D[vectorFieldE]*)];
   	Print[plot];
  	{Re@out,plot(*,{radvec,norvec,radvecn,rotvec,norvecc}*)}
	,
  	Re@out
  	]
]


(* ::Subsubsection::Closed:: *)
(*Sign2*)


Sign2[dat_]:=Sign[Sign[dat] + 0.0001];


(* ::Subsubsection::Closed:: *)
(*MakePerpendicular*)


MakePerpendicular[vec1_, vec2_] := NormalizeC[MakePerpendiculari[vec1, vec2]]


MakePerpendiculari = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
   vec1 - (vec1.vec2) vec2, RuntimeAttributes -> {Listable}, 
   Parallelization -> True, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NormalizeC*)


NormalizeC = Compile[{{vec, _Real, 1}}, Normalize[vec], RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*RadVecC*)


RadVecC = Compile[{{dim, _Real, 1}, {off, _Real, 2}}, 
   Table[Normalize[{i, j, k}-off[[i]]], {i, dim[[1]]}, {j, 
     dim[[2]]}, {k, dim[[3]]}], RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecC*)


NorVecC = Compile[{{off, _Real, 2}, {vec, _Real, 2}, {dim, _Real, 1}, {vox, _Real, 1}},
   Block[{offv = vox # & /@ off},
    Table[
     vec[[First@
        First@Position[offv, First@Nearest[offv, vox {i, j, k}, 1]]]],
     {i, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}]
    ], Parallelization -> True, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecR*)


NorVecR = Compile[{{angmap, _Real, 0}, {rotvec, _Real, 1}, {norvec, _Real, 1}},
   Block[{
     v1 = rotvec[[1]], v2 = rotvec[[2]], v3 = rotvec[[3]],
     W, iden = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}},
    W = -{{0, -v3, v2}, {v3, 0, -v1}, {-v2, v1, 0}};
    (iden + 
       Sin[angmap] W + (2 Sin[angmap/2]^2 MatrixPower[W, 2])).norvec
    ]
   , RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];



(* ::Subsubsection::Closed:: *)
(*CrossC*)


CrossC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
   Cross[vec1, vec2], RuntimeAttributes -> {Listable}, 
   Parallelization -> True];


(* ::Subsubsection::Closed:: *)
(*DotC*)


DotC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, vec1.vec2, 
   RuntimeAttributes -> {Listable}, Parallelization -> True];


(* ::Subsubsection::Closed:: *)
(*WallAngleMap*)


WallAngleMap[mask_, vox_, inout_] := 
 Module[{dim,cent,len,edge1,edge2,fout,fin,
   walldir,wallang,wallvec,sign,
   wallangfunc,dist,in,out},
  
  dim = Dimensions[mask];
  len = dim[[1]];
    
  (*fit the wall profile with Quadratic function*)
  {in, out} = (FitWall[#, "Quartic"]) & /@ {inout[[1, 2]], inout[[2, 2]]};
  fout = First@First@Position[out[[1]], _Real?(# != 0. &)];
  fin = First@First@Position[in[[1]], _Real?(# != 0. &)];
  
  walldir = {in, out};
wallang = Transpose[Map[(
      wallvec = Normalize[vox {1, #[[2]], 0}];
      sign = Sign2[#[[2]]];
      {#[[1]], sign VectorAngle[{1, 0, 0}, wallvec]/Degree}
      ) &, Transpose[walldir, {2, 3, 1}], {2}], {3, 1, 2}];
cent = {ConstantArray[0, len], wallang[[1, 2]]};
If[fout > 1, wallang[[2, 2, Range[fout - 1]]] = 90];
If[fin > 1, wallang[[1, 2, Range[fin - 1]]] = 90];
cent = {ConstantArray[0, len], wallang[[1, 2]]};
edge1 = {ConstantArray[ Max[walldir[[All, 1]]], len], wallang[[2, 2]]};
edge2 = {ConstantArray[ Max[vox dim], len], wallang[[2, 2]]};
wallang = 
  Transpose[{Transpose[
       vox[[1 ;; 2]] {Range[len], #[[1]]}], #[[2]]}] & /@ 
   Join[{cent}, wallang, {edge1, edge2}];

wallang = Sort[DeleteDuplicates[Flatten[wallang, 1]]];
wallangfunc = Interpolation[wallang, InterpolationOrder -> 1];
Table[
   dist = EuclideanDistance[{j, k}, inout[[1, 1, z, 2 ;;]]];
   wallangfunc[vox[[1]] z, vox[[2]] dist]
   , {z, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}
   ]
]


(* ::Subsubsection::Closed:: *)
(*FitWall*)


(*fit the waal profile for the normalized central axes*)
FitWall[data_, met_] := 
 Module[{fun, pf, fdata, xdat, points, pos},
  (*define function and data*)
  fun = Switch[met,
   "Quadratic", {1, t, t^2},
   "Cubic", {1, t, t^2, t^3},
   "Quartic", {1, t, t^2, t^3, t^4},
   _, {1, t}];
  xdat = Range[Length[data]];
  fdata = DeleteCases[Transpose[{xdat, data}], {_, {}}];
  
  (*perform the fit and gererate the fitted poins *)
  pf = Simplify@Chop@Fit[fdata, fun, t];
  points = Chop[pf /. t -> # & /@ xdat];
  
  (*set the radius to zero for slices without a mask*)
  pos = Flatten[Position[data, {}]];
  If[! (pos === {}), points[[pos]] = 0];
  {points, (Unitize[points[[#]]] (D[pf, t] /. t -> #) /. 
       0. -> 10) & /@ xdat}
  ]


(* ::Subsection:: *)
(*CentralAxes*)


(* ::Subsubsection::Closed:: *)
(*CentralAxes*)


Options[CentralAxes]={ShowFit->True,RowSize->"Automatic",Method->"Cubic"(*,Output->True*)};

SyntaxInformation[CentralAxes]={"ArgumentsPattern"->{_,_,_.,OptionsPattern[]}};

CentralAxes[mask_,vox_,opts:OptionsPattern[]]:=CentralAxes[mask,0,vox,opts]

CentralAxes[mask_,maskp_,vox_,OptionsPattern[]]:=Module[{
rad,met,row,dim,half,minmaxr,inner,outer,inout,offi,offo,vecsi,vecso,
offouti,offouto,pl1,off,vecs,pl2,offout,vecsout,fit},

(*get option values*)
rad={0,1};
met=OptionValue[Method];
row=If[OptionValue[RowSize]==="Automatic"||!IntegerQ[OptionValue[RowSize]],
Round[Sqrt[Length[mask]]],
OptionValue[RowSize]
];

(*get data dimensions*)
dim=Dimensions[mask];
(*half=CenterPoint[mask];*)
half=Drop[dim,1]/2.;
minmaxr= rad Max[(Drop[dim,1]/2)];

(*get inner and outer radius*)
{inner,outer}=GetRadius[mask,minmaxr,half];
(*fit off centers*)
{off, vecs} = FitCenterLine[inner[[1]], outer[[1]], vox, met];
{offi, vecsi} = FitCenterLine[inner[[1]], vox, met];
{offo, vecso} = FitCenterLine[outer[[1]], vox, met];

{off, vecs} = BoundCorrect[Min /@ Transpose[{inner[[2]], outer[[2]]} /. {{} -> 0}], off, vecs];
{offi, vecsi} = BoundCorrect[inner[[2]]/. {{} -> 0}, offi, vecsi];
{offo, vecso} = BoundCorrect[outer[[2]]/. {{} -> 0}, offo, vecso];
  
(*generate plots*)
pl1 = PlotRadius[Clip[2mask + maskp,{0,2}], inner, outer];
pl2 = PlotSegmentation[mask + maskp, inner, outer, {off, offi, offo}, vox];
fit = Row[{GraphicsGrid[Partition[pl1, row, row, 1, {}], ImageSize -> row*100], pl2}];

(*create output*)
offout = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ off;
offouti = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offi;
offouto = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offo;
vecsout=Reverse[{1,-1,1} #]&/@vecs;
inout = {{offouti, inner[[2]]}, {offouto, outer[[2]]}};

If[OptionValue[ShowFit]==True,Print[fit]];
If[OptionValue[ShowFit],{offout,vecsout,inout,fit},{offout,vecsout,inout}]
]


(* ::Subsubsection::Closed:: *)
(*BoundCorrect*)


BoundCorrect[points_,off_,vec_]:=Block[{vv,first,last,offo,veco},
vv = Unitize[points];
	
first = (First@Position[vv, 1])[[1]];
last = (Last@Position[vv, 1])[[1]];
offo = Join[
	{off[[first, 1]] + (first - #) (off[[first, 1]] - off[[first + 1, 1]]), off[[first, 2]] + (first - #) (off[[first, 2]] - off[[first + 1, 2]]), #} & /@ Range[1, first - 1],
	off[[Range[first, last]]],
  	{off[[last, 1]] + (# - last) (off[[last, 1]] - off[[last - 1, 1]]), off[[last, 2]] + (# - last) (off[[last, 2]] - off[[last - 1, 2]]), #} & /@ Range[last + 1, Length[vv]]
  ];
veco=Join[ConstantArray[vec[[first]],first-1],vec[[first;;last]],ConstantArray[vec[[last]],Length[vv]-last]];
{offo,veco}
]


(* ::Subsubsection::Closed:: *)
(*CenterPoint*)


CenterPoint[mask_]:=Module[{half},
DynamicModule[{halfi},
halfi=Dimensions[mask[[1]]]/2;
DialogInput[{
LocatorPane[Dynamic[halfi],Image[Mean[mask],ImageSize->400],Appearance->Graphics[{Red,Disk[]},ImageSize->30]],
DefaultButton["Done",DialogReturn[half=halfi]]
},WindowTitle->"Select Center",WindowFloating->True,Modal->True]
];
half
]


(* ::Subsubsection::Closed:: *)
(*GetRadius*)


(*function to get inner and outer radius of the segmentation*)
GetRadius[mask_, {minr_, maxr_}, half_] := 
 Module[{msin, tmp, comps, seg, min, mout, inner, outer,seli,selo,spos}, 
  seg = MorphologicalComponents[#] & /@ (1 - mask);
  seg = If[#[[1, 1]] == 2, # /. {2 -> 1, 1 -> 2}, #] & /@ seg;
  min = Unitize[Clip[seg, {1.5, 2}, {0, 0}]];
  mout = Unitize[1 - Clip[seg, {0, 1}, {0, 0}]];
  (*get the inner radius*)inner =
   Transpose@MapIndexed[(msin = Image[#1];
       tmp = 
        DeleteCases[(ComponentMeasurements[
            msin, {"BoundingDiskCenter", "BoundingDiskRadius", 
             "Circularity"}])[[All, 
          2]], _?((#1[[2]] > maxr) || (#1[[2]] < minr) &)];
       comps = 
        If[tmp != {}, 
         Nearest[(#[[1]] -> #) & /@ tmp, half, 1][[1]], {}];
       If[
        comps != {}, {Join[comps[[1]], (#2)], 
         comps[[2]]}, {{}, {}}]) &, min];
  (*get the outer radius*)
  outer = Transpose@MapIndexed[(msin = Image[#1];
       tmp = 
        DeleteCases[(ComponentMeasurements[
            msin, {"BoundingDiskCenter", "BoundingDiskRadius"}])[[All, 
          2]], _?((#1[[2]] > maxr) || (#1[[2]] < minr) &)];
       comps = 
        If[tmp != {}, 
         Nearest[(#[[1]] -> #) & /@ tmp, half, 1][[1]], {}];
       If[
        comps != {}, {Join[comps[[1]], (#2)], 
         comps[[2]]}, {{}, {}}]) &, mout];
    (*only define outer if inner is known*)
    seli = Unitize[inner[[2]]] /. {} -> 0;
    selo = Unitize[outer[[2]]] /. {} -> 0;
    spos = Flatten@SequencePosition[seli + selo, {2, 1}];
    If[spos =!= {},spos = spos[[2]];outer[[All, spos ;;]] = outer[[All, spos ;;]] /. {{_, _, _} -> {}, _Real -> {}}];
  (*give inner and outer radius (centerpoint,radius)*)
  {inner, outer}
  ]


(* ::Subsubsection::Closed:: *)
(*FitCenterLine*)


(*fit the center line for the average inner and outer center points*)
FitCenterLine[inner_, outer_, vox_, met_] := 
 Module[{data},
  data = Mean[DeleteCases[#, {}]] & /@ Transpose[{inner, outer}];
  FitCenterLine[data, vox, met]
  ]

FitCenterLine[datai_, vox_, met_] := 
 Module[{fun, pf, xdat, data, fdata},
  data = datai /. {Mean[{}] -> {{}, {}, {}}, {} -> {{}, {}, {}}};
  
  fun = Switch[met, 
  	"Quadratic", {1, t, t^2}, 
    "Cubic", {1, t, t^2, t^3}, 
    "Quartic", {1, t, t^2, t^3, t^4},
    _, {1, t}];
  
  xdat = Range[Length[data]];
  fdata = DeleteCases[Transpose[{Range[Length[#]], #}], {_, {}}] & /@ Transpose[data];
  
  pf = Simplify@Chop@Fit[#1, fun, t] & /@ fdata;
  
  {
  	Transpose[If[NumberQ[#], ConstantArray[#, Length[xdat]], # /. t -> xdat] & /@ pf]
  , (Normalize[D[Reverse[vox] pf, t] /. t -> #] & /@ xdat)}
  ]


(* ::Subsubsection::Closed:: *)
(*PlotRadius*)


(*Plot the radus and center points on the mask*)
PlotRadius[mask_,inner_,outer_]:=MapThread[(
Show[
Image[#1/Max[mask],ImageSize->100],
If[#2[[1]]!={},Graphics[{Red,Thick,Circle[#2[[1,1;;2]]+{-0.25,0.25},#2[[2]]]}],Graphics[]],
If[#2[[1]]!={},Graphics[{Red,PointSize[Medium],Point[#2[[1,1;;2]]]}],Graphics[]],
If[#3[[1]]!={},Graphics[{Blue,Thick,Circle[#3[[1,1;;2]]+{-0.25,0.25},#3[[2]]]}],Graphics[]],
If[#3[[1]]!={},Graphics[{Blue,PointSize[Medium],Point[#3[[1,1;;2]]]}],Graphics[]]
]
)&,{mask,Transpose@inner,Transpose@outer}]


(* ::Subsubsection::Closed:: *)
(*PlotSegmentation*)


PlotSegmentation[mask_, inner_, outer_, {off_, offi_, offo_}, vox_] :=
  Module[{voxl, offp, offip, offop},
  voxl = Reverse[vox];
  
  offp = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[off, {}];
  offip = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offi, {}];
  offop = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offo, {}];
  
  Show[
   PlotMaskVolume[mask, vox],
   (*center points*)
   ListPointPlot3D[offp, PlotStyle -> Directive[{Thick, Black, PointSize[Large]}]],
   Graphics3D[{Thick, Black, Line[offp]}],
   
   ListPointPlot3D[Delete[outer[[1]], Position[outer[[2]], {}]], PlotStyle -> Directive[{Thick, Blue, PointSize[Large]}]],
   Graphics3D[{Thick, Blue, Line[Delete[offop, Position[outer[[2]], {}]]]}],
   
   ListPointPlot3D[Delete[offip, Position[inner[[2]], {}]], PlotStyle -> Directive[{Thick, Red, PointSize[Large]}]],
   Graphics3D[{Thick, Red, Line[Delete[offip, Position[inner[[2]], {}]]]}],
   
   (*Plot the segmented outlines*)
   If[outer[[2, #]] === {}, Graphics3D[], ParametricPlot3D[{outer[[2, #]] Sin[u], outer[[2, #]] voxl[[1]]/voxl[[2]] Cos[u],0} + offop[[#]], {u, 0, 2 Pi}, 
       PlotStyle -> Directive[{Thick, Blue, Opacity[.5]}]]] & /@ Range[Length[mask]], 
   If[inner[[2, #]] === {}, Graphics3D[], ParametricPlot3D[{inner[[2, #]] Sin[u], inner[[2, #]] voxl[[1]]/voxl[[2]] Cos[u], 0} + offip[[#]], {u, 0, 2 Pi}, 
       PlotStyle -> Directive[{Thick, Red, Opacity[.5]}]]] & /@ Range[Length[mask]],ImageSize->400
       
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotMaskVolume*)


Options[PlotMaskVolume]={Filter->True}

PlotMaskVolume[mask_,vox_,color_:Darker[Gray],OptionsPattern[]] := Module[{pmask,dim},
	pmask = ArrayPad[Map[Reverse, 
		If[OptionValue[Filter],
		GaussianFilter[Clip[mask], 1],
		Clip[mask]
		], {1}], 1];
	dim=Dimensions[pmask];
	ListContourPlot3D[pmask, Contours -> {.4}, ContourStyle -> {color, Opacity[.5]}, Mesh -> False, 
    Lighting -> "Neutral", BoundaryStyle -> None, PlotRange -> (Thread[{{0, 0, 0}, Reverse@dim - 1}]), 
    BoxRatios -> Reverse[(vox (dim + 2))], Axes -> True, ImageSize -> 400, SphericalRegion -> True]
  ]


(* ::Subsection:: *)
(*CardiacSegment*)


(* ::Subsubsection::Closed:: *)
(*CardiacSegment*)


Options[CardiacSegment]={StartPoints->"Default",StartSlices->"Default",LineThreshold->.5,LineStep->.5(*,SegmentAngle->2*)};

SyntaxInformation[CardiacSegment] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

CardiacSegment[data_,mask_,off_,OptionsPattern[]]:=DialogInput[{
DynamicModule[{
radiusStart,centers,pointsIn,coordinates,angles,segmask, segang, points,
lines,centerpl,slices,api,midi,basi,sti,endi,carPl,colsOver,car,lm,pos,st,en,app,seg,allpli},

radiusStart=ConstantArray[Max[Dimensions[mask]]/8,Length[mask]];
centers=Reverse/@off[[All,2;;3]];

pointsIn=If[OptionValue[StartPoints]==="Default",
Transpose[{
centers-Transpose@{radiusStart,radiusStart},
centers-Transpose@{radiusStart,-radiusStart}
},{2,1,3}]
,
Reverse@OptionValue[StartPoints]
];

coordinates=(Reverse/@Position[#,1])&/@mask;
angles=Table[i,{i,0,359,1}]Degree;
lines=LinePoints[mask,off,LineThreshold->OptionValue[LineThreshold],LineStep->OptionValue[LineStep]];

(*static plots*)
centerpl=Graphics[{Red ,Disk[#,1]}]&/@centers;

slices=Length[mask];

{sti,api,midi,basi,endi}=
If[OptionValue[StartSlices]==="Default",
	pos = Position[Max[#] & /@ mask, 1];
	st = First@First[pos-1];
	en = First@Last[pos];
	app=Round[(en-st)/7];
	seg=Ceiling@Range[st + app, en - (en - (app + st))/3, (en - (app + st))/3];
	Flatten[{st,seg,en}]
	,
	OptionValue[StartSlices]
];

carPl = ArrayPlot[car = Reverse@Total[Transpose[mask]], ColorFunction -> "GrayTones", Frame -> False,ImageSize -> {200, 200}, AspectRatio -> 1];
colsOver = 0 car;lm = Dimensions[car];
allpli=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lm[[2]], #1}}]} &, {{sti,api,midi,basi,endi}, {Gray, Orange, Blue, Red, Purple}}]];

Manipulate[
(*slice sements*)
end=Clip[end,{bas,slices}];
bas=Clip[bas,{mid,end}];
ap=Clip[ap,{start,mid}];
mid=Clip[mid,{ap,bas}];
start=Clip[start,{0,ap}];
(*app=Clip[app,{0,mid}];*)
n=Clip[n,{1,slices}];
allpl=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lm[[2]], #1}}]} &, {{start,ap,mid,bas,end}, {Gray, Orange, Blue, Red, Purple}}]];

(*segment ranges*)
apex=Range[start+1,ap];
apical=Range[ap+1,mid];
midcavity=Range[mid+1,bas];
basal=Range[bas+1,end];
none=Complement[Range[1,slices],Flatten[{apex,apical,midcavity,basal}]];

(*Colors*)
backcols=Flatten[Thread/@Thread[{apex,apical,midcavity,basal,none}->{Orange,Blue,Red,Purple,Gray}]];
colls=backcols[[All,2]];
backcol=n/.backcols;

(*segments*)
segments=If[!NumberQ[segmi],
Thread[{apex,apical,midcavity,basal,none}->{1,4,6,6,1}],
If[slcgrp,
DeleteCases[Thread[{apex,apical,midcavity,basal}->{segmi,segmi,segmi,segmi}],{}->_],
{Range[slices]->segmi}
]
];
segm=n/.Flatten[Thread/@segments];

(*get correct center, calcualte angles and rad*)
cent=centers[[n]];
rad=Clip[RadCalcC[points[[n]],cent],{5,Min[Dimensions[mask[[1]]]/3]}];
angs= VecAngleC[points[[n]],cent,segm,rev];

(*plots*)
anatomypl=ArrayPlot[data[[n]],ColorFunction->"GrayTones",FrameTicks->Automatic,DataReversed->True,ImageSize->400,Mesh->mesh,
LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],FrameTicksStyle->Directive[{Black,Thick}],FrameStyle->Directive[{Thick,backcol}]];
maskpl=If[masktype,
ArrayPlot[(1-Ceiling[GaussianFilter[mask[[n]],2]-linetr]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True],
ArrayPlot[(1-mask[[n]]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True]
];

(*disks*)
polplot=If[MemberQ[display,4],
dsks=RegionDisk[cent,angs,rad,rev]; 
Graphics[Table[{Opacity[0.5],ColFun[i,segm],dsks[[i]]},{i,1,segm}]],
Graphics[]];
(*lines*)
If[MemberQ[display,2]||MemberQ[display,5],
angsp=Angpart[angs,angles[[1;;;;astep]],rev]
];
(*lines1 - full lines*)
lineplot=If[MemberQ[display,2], 
segpts=Map[RotateRadC[rad,cent,#]&,angsp,{2}];
Graphics[Table[{ColFun[i,segm],Line[{cent,#}]&/@segpts[[i]]},{i,1,segm}]],Graphics[]];
(*lines2 - mask lines*)
lineplot2=If[MemberQ[display,5],
Graphics[Table[{ColFun[i,segm],Line[lines[[n,(#/Degree+1)]]]&/@angsp[[i]]},{i,1,segm}]],Graphics[]];
(*points*)
pointplot=If[MemberQ[display,3],
pts=RegionPoins[cent,angs,coordinates[[n]]];
Graphics[Table[{ColFun[i,segm],PointSize[Large],Point[#-{.5,.5}&/@pts[[i]]]},{i,1,segm}]],Graphics[]];
(*circle and arrows*)
circplot=If[MemberQ[display,1],If[segm==1,
Graphics[{backcol,Thick,Circle[cent,rad]}],
segpt=RotateRadC[rad,cent,#]&/@angs; 
Graphics[{{Thick,backcol,Arrow[{cent,#}]&/@segpt},{backcol,Thick,Circle[cent,rad]}}]
],Graphics[]];

(*locator pane*)
Column[{
(*sclice buttons*)
Row[{Button["<<<",n=1],Button["<<", n=start],Button["<",n=n-1],
	Button[">",n=n+1],Button[">>",n=end],Button[">>>",n=slices]}]
,
(*locator pane *)
LocatorPane[
(*dynamic points*)
Dynamic[points[[n]]],
(*dynamic plot*)
Dynamic[Show[anatomypl,maskpl,polplot,lineplot,lineplot2,pointplot,circplot,centerpl[[n]]
(*,PlotLabel\[Rule]{segm,segments}*)]]
(*locator appearance*)
,Appearance->{Graphics[{Green,Disk[]},ImageSize->15],Graphics[{Blue,Disk[]},ImageSize->15]}
]
},Alignment->Center]
,
(*manipulate controls*)
{{n,Round[slices/2],"Slice"},1,slices,1},
{{mop,.2,"Mask opacity"},0,1},
{{masktype,False,"show lines mask"},{True->"threshold mask",False->"normal mask"}},
{{segmi,"AHA","Number of segments"},{1->"1 per sliec",4->"4 per slice",6->"6 per slice","AHA"->"AHA-17"},ControlType->SetterBar},
PaneSelector[{
False->"",
True-> Control[{{slcgrp,False,"Use slice grouping:"},{True->"group by slice",False->"group by region"},ControlType->SetterBar}]
},
Dynamic[NumberQ[segmi]]],
Delimiter,

(*point controls*)
Row[{
Button["Reverse points",rev=If[rev==1,-1,1];points=Reverse/@points,FrameMargins->0,Appearance->If[rev==-1,"Pressed","Normal"]],
Button["Reset points",points=pointsIn,FrameMargins->0],
Button["Rotate points -90",points=MapThread[{RotatePointC[#1[[1]],#2,-.5Pi],RotatePointC[#1[[2]],#2,-.5Pi]}&,{points,centers}],FrameMargins->0],
Button["Rotate points 90",points=MapThread[{RotatePointC[#1[[1]],#2,.5Pi],RotatePointC[#1[[2]],#2,.5Pi]}&,{points,centers}],FrameMargins->0]
}],

(*display controls*)
Delimiter,
{{display,{1,5},"display"},{1->"arrows",4->"disks",2->"lines",5->"lines mask",3->"points mask"},ControlType->TogglerBar},
{{mesh,False,"show gridlines"},{False,True}},
{{astep,2,"line resolution"},1,5,1},
{{linetr,OptionValue[LineThreshold],"line threshold"},0.1,1,.05},
Button["recalculate lines",lines=LinePoints[mask,off,LineThreshold->linetr,LineStep->OptionValue[LineStep]];],

Delimiter,
(*slice segmentation*)
Column[{
(*slices slider*)
Row[{
VerticalSlider[Dynamic[start],{0,slices,1},Background->Lighter@Gray, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[ap],{0,slices,1},Background->Lighter@Orange, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[mid],{0,slices,1},Background->Lighter@Blue, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[bas],{0,slices,1},Background->Lighter@Red, Appearance -> {Vertical, Tiny}],"  ",
VerticalSlider[Dynamic[end],{0,slices,1},Background->Lighter@Purple, Appearance -> {Vertical, Tiny}],"      ",
Dynamic[Show[carPl,allpl]]
}]

}]
,
(*close buttons*)
Delimiter,
Row[{
DefaultButton["Done",DialogReturn[
{segmask, segang, points}=GenerateOutput[points,centers,segments[[1;;4]],rev,NumberQ[segmi],slcgrp,coordinates,Dimensions[mask],lines];
{segmask,segang, {points,{start,ap,mid,bas,end}}}
]],
CancelButton["Cancel",DialogReturn[{"Cancel","Cancel","Cancel"}]]
}],

(*hidden controls*)
{points,ControlType->None},
{angs,ControlType->None},
{angsp,ControlType->None},
{angsp2,ControlType->None},
{segpt,ControlType->None},
{segm,ControlType->None},
{segpts,ControlType->None},
{rad,ControlType->None},
{cent,ControlType->None},
{pols,ControlType->None},
{dsks,ControlType->None},
{pts,ControlType->None},
{{rev,1},ControlType->None},
{{slcgrp,False},ControlType->None},

{{ap,api},ControlType->None},
(*{{app,api},ControlType->None},*)
{{mid,midi},ControlType->None},
{{bas,basi},ControlType->None},
{{end,endi},ControlType->None},
{{start,sti},ControlType->None},
{{allpl,allpli},ControlType->None},

{apex,ControlType->None},
{apical,ControlType->None},
{midcavity,ControlType->None},
{basal,ControlType->None},

{segments,ControlType->None},
{backcols,ControlType->None},
{backcol,ControlType->None},
{colls,ControlType->None},

{anatomypl,ControlType->None},
{maskpl,ControlType->None},
{polplot,ControlType->None},
{lineplot,ControlType->None},
{lineplot2,ControlType->None},
{pointplot,ControlType->None},
{circplot,ControlType->None},

(*initialization*)
Initialization:>{points=pointsIn},
ControlPlacement->Left,
SynchronousUpdating->True
]
]
(*close dialog input*)
},WindowTitle->"Segement the heart",WindowFloating->True,Modal->True];


(* ::Subsubsection::Closed:: *)
(*ColFun*)


ColFun[i_,seg_]:=If[seg==1,ColorData["Rainbow"][0.],ColorData["Rainbow"][((i-1)/(seg-1.))]]


(* ::Subsubsection::Closed:: *)
(*RegionDisk*)


RegionDisk[cent_,ang_,ran_,rev_]:=Block[{ans},
ans=Partition[If[Negative[#],#+2Pi,#]&/@(-ang+0.5Pi),2,1,1];
If[rev==1,
Disk[cent,ran,If[#[[1]]>#[[2]],#,#+{0,-2Pi}]]&/@ans,
Disk[cent,ran,If[#[[2]]>#[[1]],Reverse@#,Reverse[#+{0,+2Pi}]]]&/@ans
]]


(* ::Subsubsection::Closed:: *)
(*RegionPoints*)


RegionPoins[cent_,angs_,points_]:=Block[{pts},
If[Length[angs]==1,
	{points},
	If[points==={},
		ConstantArray[{},Length[angs]]
		,
		pts=Partition[RotateRadC[5000,cent,#]&/@angs,2,1,1];
		Pick[points,RegionMember[Polygon[Prepend[#,cent]+0.5],points]]&/@pts
	]
]
]


(* ::Subsubsection::Closed:: *)
(*RadCalcC*)


RadCalcC=Compile[{{pnt,_Real,2},{cent,_Real,1}},Mean[Norm[#-cent]&/@pnt]];


(* ::Subsubsection::Closed:: *)
(*VecAngleC*)


VecAngleC=Compile[{{pnt,_Real,2},{cent,_Real,1},{num,_Real,0},{rev,_Real,0}},
Block[{x1,x2,y1,y2,ang1,ang2,angs,angs2,angsout,diff},
{{x1,y1},{x2,y2}}=(#-cent&/@pnt);
ang1=ArcTan[y1,x1];
ang2=ArcTan[y2,x2];
diff=If[rev==1,ang2-ang1,ang1-ang2];
diff=If[Negative[diff],2Pi+diff,diff];

angs={ang1,ang2,0.5 diff,0.25(2Pi- diff),1/3.(2Pi- diff)};

angs2=If[num==6,
{
angs[[1]]-(rev angs[[4]]),angs[[1]],
angs[[1]]+(rev angs[[3]]),angs[[2]],
angs[[2]]+(rev angs[[4]]),angs[[2]]+(rev 2 angs[[4]])}
,
If[num==4,
{
angs[[1]]-(rev angs[[5]]),angs[[1]],
angs[[2]],angs[[2]]+(rev angs[[5]])}
,
{angs[[1]]}
]
];
If[Negative[#],2Pi+#,#]&/@angs2
]];


(* ::Subsubsection::Closed:: *)
(*RotatePointC*)


RotatePointC=Compile[{{pt,_Real,1},{cent,_Real,1},{ang,_Real,0}},({{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}}.(pt-cent))+cent];


(* ::Subsubsection::Closed:: *)
(*RotateRadC*)


RotateRadC=Compile[{{rad,_Real,0},{cent,_Real,1},{ang,_Real,0}},(cent+{{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}}.{0,rad})];


(* ::Subsubsection::Closed:: *)
(*AngPart*)


Angpart[angs_,angles_,rev_]:=Block[{pang,end,start,sel},
pang=Partition[angs,2,1,1];
(
{start,end}=If[rev==1,#,Reverse@#];
If[start<end,
Select[angles ,start<#<=end&],
Select[angles ,#<=end||start<#&]
])&/@pang
]


(* ::Subsubsection::Closed:: *)
(*LinePoints*)


Options[LinePoints]={LineThreshold->.3,LineStep->.5};

LinePoints[mask_,off_,OptionsPattern[]]:=Block[{
int2D,dimy,dimx,step,test,ii,vec,x,y,
cent,points,points2,vals,vals2
},
Table[
int2D=ListInterpolation[GaussianFilter[mask[[n]],2],InterpolationOrder->1];

{dimy,dimx}=Dimensions[mask[[n]]];
step=OptionValue[LineStep];
test=(
ii=0;
vec=#;
{x,y}=cent=off[[n,{3,2}]];

points=Reap[While[
(1+step<=y<=dimy-step-1&&1+step<=x<=dimx-step-1),
Sow[{x,y}=cent+(ii step)vec];
ii++;
]][[2,1]];
vals=Ceiling[(int2D[#[[2]]+0.5,#[[1]]+0.5]-OptionValue[LineThreshold]&/@points)];
vals2=DeleteCases[Thread[{points,vals}],{_,0}];
points2=If[vals2==={},{},vals2[[{1,-1},1]]]
)&/@Table[RotationMatrix[-i Degree].{0.,1.} ,{i,0,359,1.}]
,{n,1,Length[mask],1}
]]


(* ::Subsubsection::Closed:: *)
(*GenerateOutput*)


GenerateOutput[points_,centers_,segments_,rev_,numSeg_,slcGrp_,coordinates_,dim_,lines_]:=Block[
{slices,segm,angs,cent,pts,dim2,sls,sgm,tmp,mask,ind,segang,
blank,msk,ptstmp,segmask,output,angles,angsp},
slices=dim[[1]];
dim2=Drop[dim,1];
segm=Flatten[Thread/@segments];
angles=Table[i,{i,0,359,1}]Degree;


(*create mask per slice from points*)
{segmask,segang}=Transpose@Table[
cent=centers[[n]];
angs= VecAngleC[points[[n]],cent,n/.segm,rev];

pts=RegionPoins[cent,angs,coordinates[[n]]];
angsp=Angpart[angs,angles,rev];
angsp=lines[[n,(#/Degree+1)]]&/@angsp;

(*Generate mask per sliec*)
blank=ConstantArray[ConstantArray[0,dim2],Length[pts]];
mask=MapThread[(
msk=#1;
ptstmp=#2;
(msk[[#[[2]],#[[1]]]]=1)&/@ptstmp;
msk
)&,{blank,pts}];
{mask,angsp}
,{n,1,slices,1}];

(*group mask slices for AHA 17 segments*)
segmask=If[!numSeg||slcGrp,
Flatten[Table[
sls=segments[[i,1]];
sgm=segments[[i,2]];
tmp=ConstantArray[0,Flatten[{sgm,dim}]];
If[sls==={},
tmp,
tmp[[All,sls]]=Transpose[segmask[[sls]]]
];
tmp
,{i,Length[segments],1,-1}],1]
,
Transpose@segmask

];

(*group radial coordinates for AHA 17 segments*)
segang=If[!numSeg||slcGrp,
Flatten[Table[
sls=segments[[i,1]];
sgm=segments[[i,2]];
If[sls==={},
ConstantArray[{},i/.{1->1,2->4,3->6,4->6}],
Transpose@MapThread[(
tmp=#1;
ind=#2;
{ind,#}&/@tmp
)&,{segang[[sls]],sls}]
]
,{i,Length[segments],1,-1}],1]
,
Transpose@MapIndexed[(
tmp=#1;
ind=First[#2];
{ind,#}&/@tmp)&,segang,1]
];
{segmask,segang,Reverse@points}
]


(* ::Subsection::Closed:: *)
(*MaskHelix*)


Options[MaskHelix]={BackgroundValue-> -100, SmoothHelix->False};

SyntaxInformation[MaskHelix] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

MaskHelix[helix_, mask_,OptionsPattern[]] := Block[{fun},
	fun=Switch[OptionValue[SmoothHelix],
	0, N[mask #] /. 0. -> OptionValue[BackgroundValue] ,
	_, N[mask MedianFilter[#, 1]] /. 0. -> OptionValue[BackgroundValue]
	]&;
	
	If[ArrayDepth[helix]==4,fun/@helix,fun[helix]]	
]


(* ::Subsection::Closed:: *)
(*BullseyePlot*)


Options[BullseyePlot]={TextOffset->.5,TextSize->12,PlotRange->Automatic, ColorFunction->"TemperatureMap", Method->"Dynamic",ImageSize->200};

SyntaxInformation[BullseyePlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

BullseyePlot[data_?ArrayQ,segMask_?ArrayQ,opts:OptionsPattern[]]:=Block[{fdata}, 
fdata=(Flatten@GetMaskData[data,#])&/@segMask;
BullseyePlot[fdata,opts]
]

BullseyePlot[dati_?ListQ,OptionsPattern[]]:=Block[{number,radius,datat,minmax,cols,pl},
number={6,6,4,1};
radius={4.9,3.6,2.3,1};

datat=If[#==={}||NumberQ[#],#,Round[Mean[#],.01]]&/@dati;

minmax=If[OptionValue[PlotRange]===Automatic,
{Min[datat],Max[datat]},
OptionValue[PlotRange]
];

cols=(
#->Show[ColorData[#,"Image"],ImageSize->100]
)&/@{"GrayTones","Rainbow","ThermometerColors","SunsetColors","TemperatureMap","GrayYellowTones","BlueGreenYellow","AvocadoColors","SouthwestColors"};

DynamicModule[{col,disks,text,pts,sdata,min,max,
data=datat,
colors=cols
},

min=minmax[[1]];
max=minmax[[2]];

max=If[max<=min,min+0.1,max];

sdata=(data-min)/(max-min);

pts=Flatten[Table[
If[i==4,{{0,0}},
RotationMatrix[# Degree].{0,radius[[i]]-1.3OptionValue[TextOffset]}&/@Range[0,359,360/number[[i]]]
],{i,4}],1];

disks=Flatten[{
Table[{col,Disk[{0,0},radius[[1]],Pi/3{i,i+1}]},{i,1,6}],
Table[{col,Disk[{0,0},radius[[2]],Pi/3{i,i+1}]},{i,1,6}],
Table[{col,Disk[{0,0},radius[[3]],(i-1) Pi/2+{Pi/4,3Pi/4}]},{i,1,4}],
{{col,Disk[{0,0},radius[[4]],{0,2Pi}]}}
},1];

If[OptionValue[Method]==="Dynamic",

(*dynamic plot*)
pl=Manipulate[

blcol=If[colf=="GrayTones",Darker[Red],Gray];
colfunc=ColorData[colf][If[cstyle,1-#,#]]&;

text=Table[Text[Style[
Switch[textVal,
1,If[data[[i]]==={},"",i],
2,If[data[[i]]==={},"",data[[i]]]
],Bold,FontFamily->"Helvetica",Black,FontSize->OptionValue[TextSize]],pts[[i]]],{i,17}];

Legended[Graphics[
{
EdgeForm[{Thick,Black}],
MapThread[#1/.If[#2==={},col->blcol,col->colfunc[#2]]&,{disks,sdata}],
If[pText,text]
},ImageSize->400],
BarLegend[{colf,{min,max}},LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica",FontSize->OptionValue[TextSize]}],LegendMarkerSize->350]]
,
{{pText,True,"Show labels"},{True,False}},
{{textVal,2,"Label"},{1->"Segment",2->"Value"}},
{{colf,OptionValue[ColorFunction],"Color function"},colors},
{{cstyle,False,"Reverse color"},{True,False}},
{{blcol,Gray},ControlType->None},
{{colfunc,Gray},ControlType->None}
]
,

(*static plot*)
Block[{colf,blcol,colfunc},
colf=OptionValue[ColorFunction];
blcol=If[colf=="GrayTones",Darker[Red],Gray];
colfunc=ColorData[colf][If[False,1-#,#]]&;
text=Table[Text[Style[If[data[[i]]==={},"",data[[i]]],Bold,FontFamily->"Helvetica",Black,FontSize->OptionValue[TextSize]],pts[[i]]],{i,17}];

pl=Legended[Graphics[
{
EdgeForm[{Thick,Black}],
MapThread[#1/.If[#2==={},col->blcol,col->colfunc[#2]]&,{disks,sdata}],
text
},ImageSize->OptionValue[ImageSize]],
BarLegend[{colf,{min,max}},LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica",FontSize->OptionValue[TextSize]}],LegendMarkerSize->0.8 OptionValue[ImageSize]]]

]
]
];

(*Output plot or plotwindow*)
If[OptionValue[Method]==="Dynamic",
NotebookClose[plotwindow];
plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pl}, WindowSize -> All, WindowTitle -> "Plot data window"]];
,
pl]

]


(* ::Subsection::Closed:: *)
(*RadialSample*)


Options[RadialSample]={RadialSamples->10,DropSamples->0};

SyntaxInformation[RadialSample] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RadialSample[mask_,data_,segang_,OptionsPattern[]]:=Block[{
infunc,maskm,dat,pos,val,output, intfunc,slice,pts,int,ptsr,vals},

(*slice by slice interpolation function*)
intfunc = MapThread[(
     pos = Position[Round[#1], 1];
     dat = #1 #2;
     val = dat[[#[[1]], #[[2]]]] & /@ pos;
     With[{
       intdat = N@Thread[{pos, val}],
       extdat = N@Thread[pos -> val]
       },
      If[!(pos === {}),
       Interpolation[intdat, InterpolationOrder -> 1, "ExtrapolationHandler"->{(Mean@Nearest[extdat, {#1, #2}, 3]) &, "WarningMessage" -> False}]]
      ]
     ) &, {mask, data}, 1];

(*generate output by radial sampleling segments*)
output=Map[(
slice=#[[1]];
pts=#[[2]];
int=intfunc[[slice]];

If[FreeQ[pts, {}],
(*get radial pts steps*)
ptsr=PointRangeC[pts,OptionValue[RadialSamples],OptionValue[DropSamples]]+0.5;
vals=int @@ Reverse[Transpose[ptsr, {2, 3, 1}]];
,
ptsr=vals={}];
{ptsr,vals}

)&,segang,{2}];

{output[[All,All,1]],output[[All,All,2]]}
]


(* ::Subsection::Closed:: *)
(*PlotSegmentsMask*)


SyntaxInformation[
   PlotSegmentsMask] = {"ArgumentsPattern" -> {_, _, _}};

PlotSegmentMask[maski_, segmaski_, vox_] := DynamicModule[{heart, seg,pan},
  
  heart = PlotMaskVolume[maski, vox];
  seg = PlotMaskVolume[segmaski[[#]], vox, Red,Filter->False] & /@ 
    Range[Length[segmaski]];
  
  pan=Manipulate[
   GraphicsGrid[
    {
     {Show[heart, seg[[n]]],
      Show[heart, seg[[n]], ViewPoint -> Front, 
       Method -> {"RotationControl" -> None}]},
     {Show[heart, seg[[n]], ViewPoint -> Top, 
       Method -> {"RotationControl" -> None}],
      Show[heart, seg[[n]], ViewPoint -> Left, 
       Method -> {"RotationControl" -> None}]}
     }
    , ImageSize -> 600]
   , {{n,1,"Segment"}, 1, Length[segmaski], 1}];
  
  NotebookClose[plotwindow];
  plotwindow = 
   CreateWindow[
    DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, 
     WindowSize -> All, WindowTitle -> "Plot data window"]];
  
  ]


(* ::Subsection:: *)
(*PlotSegments*)


(* ::Subsubsection::Closed:: *)
(*PlotSegments*)


Options[PlotSegments] = {RadialSamples -> 10};

SyntaxInformation[
   PlotSegments] = {"ArgumentsPattern" -> {_, _, _, 
     OptionsPattern[]}};

PlotSegments[data_, mask_, angs_, OptionsPattern[]] := 
 Block[{pan,size}, pan = Manipulate[size = Length[angs[[n]]] 250;
    Switch[m, 1, GraphicsRow[Show[
         ArrayPlot[data[[#[[1]]]], DataReversed -> True, 
          ColorFunction -> "GrayTones"],
         If[NumberQ[Mean[Flatten[#[[2]]]]],
          
          ListPlot[{#[[2, All, 1]], #[[2, All, 2]]}, AspectRatio -> 1,
            PlotStyle -> {Red, Orange}],
          Graphics[]
          ]
         ] & /@ angs[[n]], ImageSize -> size],
     2,
     GraphicsRow[Show[
         ArrayPlot[data[[#[[1]]]], DataReversed -> True, 
          ColorFunction -> "GrayTones"],
         If[NumberQ[Mean[Flatten[#[[2]]]]],
          
          ListPlot[
           Transpose@PointRange[#[[2]], OptionValue[RadialSamples]], 
           AspectRatio -> 1],
          Graphics[]
          ]
         ] & /@ angs[[n]], ImageSize -> size],
     3,
     GraphicsRow[
      If[NumberQ[Mean[Flatten[#[[2]]]]],
         ArrayPlot[
          Fun[mask[[#[[1]]]], Round[#[[2, All, 1]]], 
           Round[#[[2, All, 2]]]], DataReversed -> True, 
          ColorFunction -> "GrayTones"],
         ArrayPlot[mask[[#[[1]]]], DataReversed -> True, 
          ColorFunction -> "GrayTones"]
         ] & /@ angs[[n]], ImageSize -> size]
     ], {{n, 1, "segment"}, 1, Length[angs], 
     1}, {{m, 1, "plot type"}, {1 -> "start stop point", 
      2 -> "radial samples", 3 -> "mask"}}, {size, 
     ControlType -> None}];
  NotebookClose[plotwindow];
  plotwindow = 
   CreateWindow[
    DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, 
     WindowSize -> All, WindowTitle -> "Plot data window"]];
  ]


(* ::Subsubsection::Closed:: *)
(*Fun*)


Fun[mask_,pts1_,pts2_]:=Block[{tmp=mask},
(tmp[[#[[2]],#[[1]]]]=10)&/@pts1;
(tmp[[#[[2]],#[[1]]]]=-10)&/@pts2;
tmp]


(* ::Subsubsection::Closed:: *)
(*PointRange*)


PointRange[pts_,steps_]:=Block[{step=steps-1,pt1,pt2},
(
pt1=#[[2,{1,2}]];
pt2=#[[1,{1,2}]];
Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}]
)&/@pts
]

PointRange[pts_,steps_,drop_]:=Block[{step=steps-1,pt1,pt2},
(
pt1=#[[2,{1,2}]];
pt2=#[[1,{1,2}]];
Take[Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}],{1+drop,steps-drop}]
)&/@pts
]

PointRangeC = 
  Compile[{{pts, _Real, 2}, {steps, _Integer, 0}, {drop, _Integer, 0}},
   Block[{step = steps - 1, pt1, pt2},
    pt1 = pts[[2]];
    pt2 = pts[[1]];
    Take[Table[
      pt2 + (i (pt1 - pt2)/step), {i, 0, step, 1}], {1 + drop, 
      steps - drop}]
    ], RuntimeAttributes -> {Listable}, Parallelization -> True, 
   RuntimeOptions -> "Speed"
   ];


(* ::Subsection::Closed:: *)
(*TransmuralPlot*)


Options[TransmuralPlot] = {GridLineSpacing -> 10, PlotStyle -> Red, PlotRange -> Automatic, ImageSize->300,Method->"Median",PlotLabel->None}

SyntaxInformation[TransmuralPlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

TransmuralPlot[data_, OptionsPattern[]] := 
 Block[{mn, std, steps, stdM, stdP, xdata, min, max, col,pdat,dat,fil,style},
  dat=If[ArrayDepth[data]==1,
  {data},
  Switch[OptionValue[Method],
  	"Median",
  	Transpose[Quantile[data, {.5, .35, .65}]],
  	"Median95",
  	Transpose[Quantile[data, { .5, .05, .95}]],
  	"Median0",
  	Transpose[Quantile[data, {.5}]],
  	_,
	mn = Mean[data];
	std = StandardDeviation[data];
	{stdM, stdP} = {mn - std, mn + std};
	{mn,stdM,stdP}
	]
  ];
  
  steps = Length[dat[[1]]];
  xdata = (Range[0, steps - 1])/(steps - 1);
  pdat=(Thread[{xdata, #}]&/@ dat);
  
  fil=If[OptionValue[Method]=="Median0",None,{2 -> {3}}];
  
  {min, max} = If[OptionValue[PlotRange] === Automatic, MinMax[dat], OptionValue[PlotRange]];
 
 style=If[ArrayDepth[data]==1,
 	OptionValue[PlotStyle]
 	,
 	col = OptionValue[PlotStyle];
    (Directive[#, col,Thick] & /@ {Dashing[None], Dashed, Dashed})
 
 ];
  col = OptionValue[PlotStyle];
  ListLinePlot[pdat, PlotStyle ->style, 
  	Filling -> fil, FillingStyle -> Directive[Opacity[0.2], col],
   
   Axes -> False, Frame -> {{True, False}, {True, False}}, 
   FrameStyle -> Directive[{Thick, Black}], 
   LabelStyle -> Directive[{Bold, Black, 14, FontFamily -> "Helvetica"}],
   PlotRange -> {{0, 1}, {min, max}},ImageSize->OptionValue[ImageSize],PlotLabel->OptionValue[PlotLabel],
   GridLines -> {{{.5, Directive[Thick, Black, Dashed]}}, Join[System`FindDivisions[{min, max},Round[(max-min)/ OptionValue[GridLineSpacing]]], {{0, Directive[{Thick, Black}]}}]}, 
   FrameTicks -> {{{0, "Endo"}, {.5, "Mid"}, {1, "Epi"}}, Automatic}]
  ]


(* ::Subsection::Closed:: *)
(*CreateHeart*)




(* ::Section:: *)
(*End Package*)


End[](* End Private Context *)

SetAttributes[#,{Protected, ReadProtected}]&/@ Names["DTITools`CardiacTools`*"];

EndPackage[]
